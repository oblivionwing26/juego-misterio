<!DOCTYPE html>
<html>
<head>
    <title>Sistema de Acceso Restringido</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #0f0;
            font-family: 'Source+Code+Pro', monospace;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .terminal {
            border: 2px solid #0f0;
            border-radius: 5px;
            padding: 20px;
            max-width: 800px;
            margin: 20px auto;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .question {
            margin: 15px 0;
            padding: 10px;
            border-left: 3px solid #0f0;
            background: rgba(0, 50, 0, 0.3);
        }
        
        input, button, textarea, select {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 15px;
            margin: 5px;
            font-family: inherit;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        
        .lives {
            display: flex;
            justify-content: center;
            margin: 15px 0;
        }
        
        .life {
            width: 20px;
            height: 20px;
            margin: 0 5px;
            background: #0f0;
            border-radius: 50%;
            transition: all 0.3s;
        }
        
        .life.lost {
            background: #300;
            box-shadow: 0 0 5px #f00;
        }
        
        .hint {
            font-style: italic;
            color: #ff0;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .hint.show {
            opacity: 1;
        }
        
        .log {
            height: 100px;
            overflow-y: auto;
            background: rgba(0, 20, 0, 0.5);
            padding: 10px;
            margin-top: 20px;
            border: 1px solid #0f0;
            font-size: 12px;
        }
        
        .log-entry {
            margin: 2px 0;
        }
        
        .cursor {
            display: inline-block;
            width: 10px;
            height: 20px;
            background: #0f0;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        /* Estilos para los retos */
        .reto-container {
            text-align: center;
            padding: 20px;
        }
        
        .reto-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #ff0;
        }
        
        .reto-description {
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .game-area {
            background: rgba(0, 30, 0, 0.5);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
            min-height: 200px;
            position: relative;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: #0f0;
            width: 0%;
            transition: width 0.5s;
        }
        
        /* Estilos para el juego del dinosaurio */
        .dino-game {
            position: relative;
            height: 250px;
            overflow: hidden;
            border: 1px solid #0f0;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 70%, #8FBC8F 70%, #228B22 100%);
        }
        
        .dino {
            position: absolute;
            bottom: 60px;
            left: 50px;
            width: 50px;
            height: 50px;
            font-size: 40px;
            line-height: 50px;
            text-align: center;
            transition: bottom 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
            transform: scaleX(-1); /* Girar para que mire a la derecha */
        }
        
        .dino.jumping {
            animation: jump 0.8s ease-out;
        }
        
        @keyframes jump {
            0% { bottom: 60px; }
            50% { bottom: 160px; }
            100% { bottom: 60px; }
        }
        
        .dino.running {
            animation: run 0.5s steps(2) infinite;
        }
        
        @keyframes run {
            0% { transform: scaleX(-1) translateX(0); }
            100% { transform: scaleX(-1) translateX(10px); }
        }
        
        .obstacle {
            position: absolute;
            bottom: 60px;
            right: 0;
            font-size: 35px;
            width: 35px;
            height: 35px;
            text-align: center;
            z-index: 5;
        }
        
        .ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 60px;
            background: #228B22;
            z-index: 1;
        }
        
        .mountain {
            position: absolute;
            bottom: 60px;
            width: 0;
            height: 0;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            border-bottom: 100px solid #2E8B57;
            z-index: 2;
        }
        
        .cloud {
            position: absolute;
            color: #fff;
            font-size: 40px;
            animation: cloudMove 20s linear infinite;
            z-index: 3;
        }
        
        @keyframes cloudMove {
            from { right: -100px; }
            to { right: 100%; }
        }
        
        .score {
            font-size: 1.2em;
            margin: 10px 0;
        }
        
        /* Estilos para el juego de memoria secuencial */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        
        .memory-cell {
            width: 60px;
            height: 60px;
            background: #222;
            border: 1px solid #0f0;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            transform-style: preserve-3d;
        }
        
        .memory-cell.flipped {
            transform: rotateY(180deg);
        }
        
        .memory-cell-front, .memory-cell-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
        }
        
        .memory-cell-front {
            background: #222;
            color: #0f0;
        }
        
        .memory-cell-back {
            background: #0a0;
            color: #000;
            transform: rotateY(180deg);
        }
        
        .memory-cell.correct {
            animation: pulse 0.5s;
        }
        
        .memory-cell.wrong {
            animation: shake 0.5s;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1) rotateY(180deg); }
            50% { transform: scale(1.2) rotateY(180deg); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0) rotateY(180deg); }
            25% { transform: translateX(-5px) rotateY(180deg); }
            75% { transform: translateX(5px) rotateY(180deg); }
        }
        
        .round-info {
            font-size: 1.1em;
            margin: 10px 0;
        }
        
        .sequence-display {
            font-size: 1.3em;
            margin: 15px 0;
            min-height: 30px;
        }
        
        /* Estilos para el juego de l√≥gica binaria */
        .binary-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .binary-operation {
            font-size: 1.8em;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            font-family: 'Source Code Pro', monospace;
        }
        
        .binary-input {
            font-size: 1.5em;
            width: 200px;
            text-align: center;
        }
        
        .binary-hint {
            font-style: italic;
            color: #ff0;
            margin: 10px 0;
            font-size: 0.9em;
        }
        
        .binary-level {
            font-size: 1.2em;
            margin: 10px 0;
        }
        
        .binary-attempts {
            font-size: 1em;
            margin: 5px 0;
            color: #aaa;
        }
        
        /* Estilos para el juego de esteganograf√≠a */
        .stego-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .stego-text {
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Source Code Pro', monospace;
            line-height: 1.6;
            font-size: 1em;
        }
        
        .stego-hint {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ff0;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-style: italic;
            color: #ff0;
        }
        
        .stego-input {
            width: 300px;
            text-align: center;
            font-size: 1.2em;
        }
        
        .stego-tools {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .stego-tool {
            padding: 8px 12px;
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid #0f0;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .stego-tool:hover {
            background: rgba(0, 100, 0, 0.5);
            box-shadow: 0 0 5px #0f0;
        }
        
        .stego-colors {
            display: flex;
            gap: 5px;
            margin: 15px 0;
            justify-content: center;
        }
        
        .color-box {
            width: 30px;
            height: 30px;
            border: 1px solid #0f0;
            border-radius: 3px;
        }
        
        /* Estilos para la capa final de seguridad */
        .final-security {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .security-text {
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            width: 100%;
            font-family: 'Source Code Pro', monospace;
            line-height: 1.6;
            font-size: 1em;
            word-break: break-all;
        }
        
        .security-tools {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }
        
        .tool-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .tool-row label {
            min-width: 120px;
            text-align: right;
        }
        
        .tool-row input, .tool-row select {
            flex: 1;
        }
        
        .book-excerpt {
            background: rgba(0, 20, 0, 0.5);
            border: 1px dashed #0f0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .security-hint {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ff0;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-style: italic;
            color: #ff0;
        }
        
        /* Panel de desarrollo */
        .dev-panel {
            margin-top: 20px;
            text-align: center;
            padding: 10px;
            border: 1px dashed #0f0;
            border-radius: 5px;
        }
        
        /* Estilos para el Reto 6: LSB Canvas Interactivo */
        .lsb-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        }
        
        .lsb-canvas-wrapper {
            position: relative;
            border: 2px solid #0f0;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
            background: #000;
            padding: 10px;
        }
        
        #lsb-canvas {
            display: block;
            max-width: 100%;
            cursor: crosshair;
            image-rendering: pixelated;
        }
        
        .lsb-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            width: 100%;
            margin: 20px 0;
        }
        
        .lsb-control-panel {
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
        }
        
        .lsb-control-panel h3 {
            color: #ff0;
            margin-bottom: 10px;
            font-size: 1em;
            border-bottom: 1px solid #0f0;
            padding-bottom: 5px;
        }
        
        .lsb-button {
            width: 100%;
            margin: 5px 0;
            padding: 10px;
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid #0f0;
            color: #0f0;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }
        
        .lsb-button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        
        .lsb-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pixel-info {
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 10px;
            font-size: 0.9em;
            margin: 10px 0;
        }
        
        .pixel-info-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px dotted #0f0;
        }
        
        .binary-display {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        
        .binary-row {
            display: flex;
            gap: 10px;
            margin: 5px 0;
            font-size: 0.85em;
        }
        
        .binary-bit {
            padding: 2px 5px;
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid #0f0;
            border-radius: 3px;
            min-width: 20px;
            text-align: center;
        }
        
        .binary-bit.one {
            background: rgba(0, 100, 0, 0.7);
            color: #fff;
        }
        
        .lsb-extracted-message {
            background: rgba(0, 50, 0, 0.7);
            border: 2px solid #ff0;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-size: 1.2em;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px #ff0; }
            50% { box-shadow: 0 0 20px #ff0; }
        }
        
        .spectrum-analyzer {
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .color-channel {
            margin: 10px 0;
        }
        
        .channel-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        .channel-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .channel-fill.red { background: #f00; }
        .channel-fill.green { background: #0f0; }
        .channel-fill.blue { background: #00f; }
        
        /* Estilos para el Reto 7: Criptograma Multi-Capa */
        .crypto-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        }
        
        .crypto-layers {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }
        
        .crypto-layer {
            background: rgba(0, 30, 0, 0.7);
            border: 2px solid #0f0;
            border-radius: 5px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .crypto-layer.locked {
            opacity: 0.5;
            pointer-events: none;
        }
        
        .crypto-layer.completed {
            border-color: #ff0;
            background: rgba(50, 50, 0, 0.3);
        }
        
        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #0f0;
        }
        
        .layer-title {
            color: #ff0;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .layer-status {
            padding: 5px 10px;
            background: rgba(0, 50, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        .layer-status.unlocked {
            color: #0f0;
        }
        
        .layer-status.locked {
            color: #f00;
        }
        
        .layer-status.completed {
            color: #ff0;
            border-color: #ff0;
        }
        
        .encrypted-text {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            word-break: break-all;
            line-height: 1.6;
            min-height: 60px;
        }
        
        .crypto-tools {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .crypto-tool {
            background: rgba(0, 40, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
        }
        
        .crypto-tool h4 {
            color: #ff0;
            margin-bottom: 10px;
            font-size: 0.95em;
        }
        
        .tool-input-group {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            align-items: center;
        }
        
        .tool-input-group label {
            min-width: 80px;
            font-size: 0.9em;
        }
        
        .tool-input-group input,
        .tool-input-group select {
            flex: 1;
        }
        
        .frequency-analysis {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .freq-chart {
            display: flex;
            align-items: flex-end;
            gap: 3px;
            height: 150px;
            margin: 15px 0;
            border-bottom: 1px solid #0f0;
            padding: 10px;
        }
        
        .freq-bar {
            flex: 1;
            background: #0f0;
            min-width: 15px;
            position: relative;
            transition: height 0.3s;
            cursor: pointer;
        }
        
        .freq-bar:hover {
            background: #ff0;
        }
        
        .freq-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
        }
        
        .freq-value {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7em;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
            white-space: nowrap;
        }
        
        .substitution-table {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .substitution-pair {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0, 40, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 3px;
            padding: 5px;
        }
        
        .substitution-pair input {
            width: 30px;
            text-align: center;
            padding: 3px;
            margin: 0;
        }
        
        .cipher-preview {
            background: rgba(0, 20, 0, 0.9);
            border: 1px dashed #ff0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
        }
        
        .crypto-hint {
            background: rgba(50, 50, 0, 0.3);
            border: 1px solid #ff0;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-style: italic;
            color: #ff0;
            font-size: 0.9em;
        }
        
        .layer-connections {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            color: #0f0;
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="terminal">
        <div class="header">
            <h1>ACCESO RESTRINGIDO - SISTEMA DE SEGURIDAD NIVEL 3</h1>
            <p>Identificaci√≥n requerida. 9 preguntas + 5 retos de verificaci√≥n.</p>
        </div>
        
        <div class="lives" id="lives">
            <div class="life"></div>
            <div class="life"></div>
            <div class="life"></div>
        </div>
        
        <div id="question-container">
            <!-- Las preguntas se cargar√°n aqu√≠ -->
        </div>
        
        <div class="hint" id="hint"></div>
        
        <div class="log" id="log">
            <div class="log-entry">[SYSTEM] Iniciando protocolo de verificaci√≥n...</div>
        </div>
        
        <!-- Panel de desarrollo -->
        <div class="dev-panel">
            <p>Panel de desarrollo:</p>
            <input type="text" id="dev-code" placeholder="Introduce c√≥digo">
            <button onclick="verificarDevCode()">Avanzar</button>
        </div>
    </div>

    <script>
        // Base de datos de preguntas
        const preguntas = [
            {
                pregunta: "Como se llama el cangrejo verde de mi casa?",
                respuesta: "Calras",
                pista: "(ü¶ûüë≥‚Äç‚ôÄÔ∏è)"
            },
            {
                pregunta: "Que me lanzaste en la playa?",
                respuesta: "Patata",
                pista: "(Una sola palabra)"
            },
            {
                pregunta: "Juego que has creado tu",
                respuesta: "Monkey gaming",
                pista: "(Mono)"
            },
            {
                pregunta: "¬øQu√© entidad invisible y absoluta, que existe sin depender de materia ni energ√≠a, fluye siempre en una sola direcci√≥n y marca el destino de todo lo que existe?",
                respuesta: "Tiempo",
                pista: "(Una palabra)"
            },
            {
                pregunta: "Que es lo que mas queria Eren",
                respuesta: "Libertad",
                pista: "üêö"
            },
            {
                pregunta: "¬øQu√© misterio une corazones distantes, desaf√≠a al tiempo y a la raz√≥n, y brilla incluso en la oscuridad m√°s profunda?",
                respuesta: "Amor",
                pista: " (1 palabra)"
            },
            {
                pregunta: "Cual es el nombre del arma de la enamorada de Gehrman en Bloodborne?",
                respuesta: "Rakuyo",
                pista: "(1 palabra)"
            },
            {
                pregunta: "Quien fue el que 'invento' la Atlantida?",
                respuesta: "Platon",
                pista: "(o primero que la menciono)"
            },
            {
                pregunta: "Quis post finem mundi vivit et novam vitam hominibus affert? (Mythos Nordicus)",
                respuesta: "L√≠f and L√≠f√ærasir",
                pista: "Ella y El"
            }
        ];
        
        // Pregunta final (ser√° el reto 3)
        const preguntaFinal = {
            pregunta: "Esta es la pregunta 10, ultima, noche en que todo empezo",
            respuesta: "19/03/2019",
            pista: " DD/MM/YYYY"
        };
        
        let preguntaActual = 0;
        let vidas = 3;
        let pistasUsadas = 0;
        let retoActual = 0;
        let juegoActivo = false;
        
        // Variables para el juego del dinosaurio
        let dinoScore = 0;
        let dinoGameInterval;
        let dinoObstacleInterval;
        let dinoJumping = false;
        let gameSpeed = 5;
        let dinoRunning = false;
        let obstacles = [];
        let nextObstacleDistance = 400;
        let doubleObstacleChance = 0.3;
        
        // Variables para el juego de memoria secuencial
        let memoryRound = 1;
        let memorySequence = [];
        let memoryPlayerSequence = [];
        let memoryShowing = false;
        let memoryTimeout;
        let memoryNumbers = [];
        let memoryGrid = [];
        
        // Variables para el juego de l√≥gica binaria
        let binaryLevel = 1;
        let binaryAttempts = 0;
        let maxBinaryAttempts = 3;
        let currentBinaryOperation = null;
        let binaryAnswer = null;
        
        // Variables para el juego de esteganograf√≠a
        let stegoAttempts = 0;
        let maxStegoAttempts = 3;
        let stegoMessage = "";
        let stegoText = "";
        let stegoRevealed = false;
        let stegoBinary = "";
        let stegoColors = [];
        
        // Variables para la capa final de seguridad
        let securityStep = 1;
        let securityAttempts = 0;
        let maxSecurityAttempts = 3;
        let securityMessage = "";
        let securityKey = "";
        
        // Variables para el Reto 6: LSB Canvas Interactivo
        let lsbCanvas = null;
        let lsbCtx = null;
        let lsbImageData = null;
        let lsbAttempts = 0;
        let maxLsbAttempts = 3;
        let lsbMessage = "SIMULACION";
        let lsbCurrentPixel = {x: 0, y: 0};
        let lsbExtractedBits = [];
        let lsbAnalysisMode = 'rgb';
        
        // Variables para el Reto 7: Criptograma Multi-Capa
        let cryptoAttempts = 0;
        let maxCryptoAttempts = 3;
        let cryptoLayers = [];
        let currentCryptoLayer = 0;
        let cryptoCompletedLayers = [];
        let cryptoFinalMessage = "RECONQUISTA";
        let caesarShift = 13;
        let vigenereKey = "CLAVE";
        let cryptoFrequencies = {};
        
        function addLog(message) {
            const log = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
        
        function mostrarPregunta() {
            // Si ya se respondieron todas las preguntas, mostrar los retos
            if (preguntaActual >= preguntas.length) {
                mostrarRetos();
                return;
            }
            
            const p = preguntas[preguntaActual];
            document.getElementById('question-container').innerHTML = `
                <div class="question">
                    <p><strong>PREGUNTA ${preguntaActual + 1}/9:</strong> ${p.pregunta}</p>
                    <input type="text" id="respuesta" placeholder="Introduce tu respuesta">
                    <button onclick="verificarRespuesta()">Verificar</button>
                    <button onclick="mostrarPista()">Usar pista (${3 - pistasUsadas} restantes)</button>
                </div>
            `;
            
            document.getElementById('respuesta').focus();
            addLog(`Mostrando pregunta ${preguntaActual + 1}: ${p.pregunta.substring(0, 20)}...`);
        }
        
        function verificarRespuesta() {
            const respuesta = document.getElementById('respuesta').value.toLowerCase().trim();
            const correcta = preguntas[preguntaActual].respuesta.toLowerCase();
            
            if (respuesta === correcta) {
                addLog("Respuesta correcta. Avanzando...");
                preguntaActual++;
                mostrarPregunta();
            } else {
                vidas--;
                actualizarVidas();
                addLog(`Respuesta incorrecta. Vidas restantes: ${vidas}`);
                
                if (vidas <= 0) {
                    document.getElementById('question-container').innerHTML = `
                        <h2>ACCESO DENEGADO</h2>
                        <p>Has bloqueado el sistema al acumular suficientes errores. Reiniciando....</p>
                        <button onclick="location.reload()">Reiniciar sistema</button>
                    `;
                    addLog("Sistema bloqueado. Demasiados intentos fallidos.");
                } else {
                    document.getElementById('respuesta').value = '';
                    document.getElementById('respuesta').focus();
                }
            }
        }
        
        function mostrarPista() {
            if (pistasUsadas < 3) {
                pistasUsadas++;
                const pista = document.getElementById('hint');
                pista.textContent = `PISTA: ${preguntas[preguntaActual].pista}`;
                pista.classList.add('show');
                addLog(`Pista solicitada: ${preguntas[preguntaActual].pista.substring(0, 20)}...`);
                
                setTimeout(() => {
                    pista.classList.remove('show');
                }, 10000);
            }
        }
        
        function actualizarVidas() {
            const elementosVida = document.querySelectorAll('.life');
            elementosVida.forEach((vida, index) => {
                if (index >= vidas) {
                    vida.classList.add('lost');
                }
            });
        }
        
        function mostrarRetos() {
            retoActual = 0;
            mostrarRetoActual();
        }
        
        function mostrarRetoActual() {
            switch(retoActual) {
                case 0:
                    mostrarReto1();
                    break;
                case 1:
                    mostrarReto2();
                    break;
                case 2:
                    mostrarReto3();
                    break;
                case 3:
                    mostrarReto4();
                    break;
                case 4:
                    mostrarReto5();
                    break;
                case 5:
                    mostrarReto6();
                    break;
                case 6:
                    mostrarReto7();
                    break;
                case 7:
                    mostrarCapaFinal();
                    break;
                default:
                    // Todos los retos completados
                    mostrarCompletado();
            }
        }
        
        function mostrarReto1() {
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">RETO 1: Escape del Dinosaurio</div>
                    <div class="reto-description">
                        <p>Alcanza 5000 puntos para superar este reto.</p>
                        <p>Presiona ESPACIO para saltar los obst√°culos.</p>
                    </div>
                    <div class="game-area">
                        <div class="dino-game" id="dino-game">
                            <div class="dino" id="dino">ü¶ï</div>
                            <div class="mountain" style="left: 200px;"></div>
                            <div class="mountain" style="left: 400px; height: 80px; border-bottom-width: 80px;"></div>
                            <div class="mountain" style="left: 600px; height: 60px; border-bottom-width: 60px;"></div>
                            <div class="cloud" style="top: 30px; right: 100px;">‚òÅÔ∏è</div>
                            <div class="cloud" style="top: 60px; right: 300px;">‚òÅÔ∏è</div>
                            <div class="cloud" style="top: 40px; right: 500px;">‚òÅÔ∏è</div>
                            <div class="ground"></div>
                        </div>
                        <div class="score">Puntos: <span id="dino-score">0</span> | Velocidad: <span id="game-speed">1</span>x</div>
                        <button id="jump-btn" onclick="saltarDino()">Saltar (ESPACIO)</button>
                        <div class="progress-bar">
                            <div class="progress" id="progress1"></div>
                        </div>
                    </div>
                </div>
            `;
            
            iniciarJuegoDino();
            addLog("Iniciando Reto 1: Escape del Dinosaurio");
            
            // A√±adir evento de teclado
            document.addEventListener('keydown', handleKeyDown);
        }
        
        function handleKeyDown(e) {
            if (retoActual === 0 && juegoActivo && e.code === 'Space') {
                e.preventDefault();
                saltarDino();
            }
        }
        
        function iniciarJuegoDino() {
            dinoScore = 0;
            gameSpeed = 5;
            juegoActivo = true;
            dinoRunning = true;
            obstacles = [];
            nextObstacleDistance = 400;
            doubleObstacleChance = 0.3;
            
            document.getElementById('dino-score').textContent = dinoScore;
            document.getElementById('game-speed').textContent = Math.floor(gameSpeed / 5);
            
            // Iniciar animaci√≥n de correr
            const dino = document.getElementById('dino');
            dino.classList.add('running');
            
            // Crear primer obst√°culo
            crearObstaculo(800);
            
            // Game loop
            dinoGameInterval = setInterval(() => {
                if (!juegoActivo) return;
                
                // Mover obst√°culos
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    obstacle.x -= gameSpeed;
                    obstacle.element.style.right = (800 - obstacle.x) + 'px';
                    
                    // Eliminar obst√°culos fuera de pantalla
                    if (obstacle.x < -50) {
                        obstacle.element.remove();
                        obstacles.splice(i, 1);
                        dinoScore += 100;
                        document.getElementById('dino-score').textContent = dinoScore;
                        updateProgress(1, dinoScore / 50);
                        
                        // Aumentar velocidad gradualmente
                        if (dinoScore % 500 === 0 && gameSpeed < 12) {
                            gameSpeed += 0.2;
                            document.getElementById('game-speed').textContent = Math.floor(gameSpeed / 5);
                        }
                        
                        // Aumentar dificultad gradualmente
                        if (dinoScore % 1000 === 0) {
                            doubleObstacleChance = Math.min(doubleObstacleChance + 0.05, 0.6);
                        }
                        
                        if (dinoScore >= 5000) {
                            completarReto1();
                        }
                    }
                    
                    // Verificar colisi√≥n
                    checkCollision(obstacle);
                }
                
                // Crear nuevos obst√°culos
                nextObstacleDistance -= gameSpeed;
                if (nextObstacleDistance <= 0) {
                    const lastObstacle = obstacles[obstacles.length - 1];
                    const newX = lastObstacle ? lastObstacle.x + 300 : 800;
                    
                    crearObstaculo(newX);
                    
                    // Posibilidad de doble obst√°culo
                    if (Math.random() < doubleObstacleChance) {
                        setTimeout(() => {
                            crearObstaculo(newX + 150);
                        }, 100);
                    }
                    
                    nextObstacleDistance = 300 + Math.random() * 200;
                }
            }, 30);
        }
        
        function crearObstaculo(x) {
            const obstacle = document.createElement('div');
            obstacle.className = 'obstacle';
            obstacle.textContent = 'üå≥';
            obstacle.style.right = (800 - x) + 'px';
            document.getElementById('dino-game').appendChild(obstacle);
            
            obstacles.push({
                element: obstacle,
                x: x
            });
        }
        
        function checkCollision(obstacle) {
            const dino = document.getElementById('dino');
            const dinoRect = dino.getBoundingClientRect();
            const obstacleRect = obstacle.element.getBoundingClientRect();
            
            // Ajustar la caja de colisi√≥n del dinosaurio seg√∫n su estado
            let dinoTop = dinoRect.top;
            let dinoBottom = dinoRect.bottom;
            let dinoLeft = dinoRect.left;
            let dinoRight = dinoRect.right;
            
            // Si est√° saltando, ajustar la caja de colisi√≥n
            if (dinoJumping) {
                dinoTop += 10;
                dinoBottom -= 10;
            }
            
            // Verificar colisi√≥n con mayor precisi√≥n
            if (
                dinoRight > obstacleRect.left + 8 &&
                dinoLeft < obstacleRect.right - 8 &&
                dinoBottom > obstacleRect.top + 8 &&
                dinoTop < obstacleRect.bottom - 8
            ) {
                // Colisi√≥n
                vidas--;
                actualizarVidas();
                addLog(`Colisi√≥n detectada. Vidas restantes: ${vidas}`);
                
                // Efecto visual de colisi√≥n
                obstacle.element.style.filter = 'brightness(2)';
                setTimeout(() => {
                    obstacle.element.style.filter = '';
                }, 300);
                
                if (vidas <= 0) {
                    finDelJuego();
                } else {
                    // Eliminar el obst√°culo con el que colision√≥
                    obstacle.element.remove();
                    const index = obstacles.indexOf(obstacle);
                    if (index > -1) {
                        obstacles.splice(index, 1);
                    }
                }
            }
        }
        
        function saltarDino() {
            if (dinoJumping) return;
            
            dinoJumping = true;
            dinoRunning = false;
            const dino = document.getElementById('dino');
            dino.classList.remove('running');
            dino.classList.add('jumping');
            
            setTimeout(() => {
                dino.classList.remove('jumping');
                dinoJumping = false;
                if (juegoActivo) {
                    dinoRunning = true;
                    dino.classList.add('running');
                }
            }, 800);
        }
        
        function completarReto1() {
            juegoActivo = false;
            clearInterval(dinoGameInterval);
            document.removeEventListener('keydown', handleKeyDown);
            
            // Limpiar obst√°culos
            obstacles.forEach(obstacle => {
                obstacle.element.remove();
            });
            obstacles = [];
            
            const dino = document.getElementById('dino');
            dino.classList.remove('running');
            
            addLog("Reto 1 completado. Puntuaci√≥n alcanzada: 5000");
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 2000);
        }
        
        function mostrarReto2() {
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">RETO 2: Memoria Secuencial</div>
                    <div class="reto-description">
                        <p>Observa la secuencia de n√∫meros y luego pulsalos en orden ascendente.</p>
                        <p>Cada ronda a√±ade un n√∫mero m√°s. Debes completar 15 rondas.</p>
                    </div>
                    <div class="game-area">
                        <div class="round-info">Ronda: <span id="memory-round">1</span> / 15</div>
                        <div class="sequence-display" id="sequence-display">Preparando secuencia...</div>
                        <div class="memory-grid" id="memory-grid">
                            <!-- Las celdas se generar√°n aqu√≠ -->
                        </div>
                        <div class="progress-bar">
                            <div class="progress" id="progress2"></div>
                        </div>
                    </div>
                </div>
            `;
            
            iniciarJuegoMemoria();
            addLog("Iniciando Reto 2: Memoria Secuencial");
        }
        
        function iniciarJuegoMemoria() {
            memoryRound = 1;
            memorySequence = [];
            memoryPlayerSequence = [];
            memoryShowing = false;
            
            crearGridMemoria();
            siguienteRondaMemoria();
        }
        
        function crearGridMemoria() {
            const grid = document.getElementById('memory-grid');
            grid.innerHTML = '';
            memoryGrid = [];
            
            // Crear 25 celdas (5x5)
            for (let i = 0; i < 25; i++) {
                const cell = document.createElement('div');
                cell.className = 'memory-cell';
                cell.dataset.index = i;
                
                // Crear frente y dorso de la carta
                const front = document.createElement('div');
                front.className = 'memory-cell-front';
                front.textContent = '?';
                
                const back = document.createElement('div');
                back.className = 'memory-cell-back';
                back.textContent = 'X'; // Por defecto, todas las celdas tienen X
                
                cell.appendChild(front);
                cell.appendChild(back);
                cell.addEventListener('click', () => pulsarCeldaMemoria(i));
                grid.appendChild(cell);
                memoryGrid.push(cell);
            }
        }
        
        function siguienteRondaMemoria() {
            document.getElementById('memory-round').textContent = memoryRound;
            updateProgress(2, (memoryRound - 1) / 15);
            
            // A√±adir nuevo n√∫mero a la secuencia
            const nuevoNumero = memoryRound;
            memorySequence.push(nuevoNumero);
            
            // Mostrar secuencia
            mostrarSecuenciaMemoria();
        }
        
        function mostrarSecuenciaMemoria() {
            memoryShowing = true;
            memoryPlayerSequence = [];
            
            const display = document.getElementById('sequence-display');
            display.textContent = 'Observa la secuencia...';
            
            // Limpiar celdas (voltear todas)
            memoryGrid.forEach(cell => {
                cell.classList.remove('flipped');
            });
            
            // Mostrar n√∫meros uno por uno
            let delay = 0;
            const positions = [];
            
            // Generar posiciones aleatorias para cada n√∫mero
            for (let i = 0; i < memorySequence.length; i++) {
                let pos;
                do {
                    pos = Math.floor(Math.random() * 25);
                } while (positions.includes(pos));
                positions.push(pos);
            }
            
            // Establecer los n√∫meros en las celdas correspondientes
            memorySequence.forEach((num, index) => {
                const cell = memoryGrid[positions[index]];
                const back = cell.querySelector('.memory-cell-back');
                back.textContent = num;
            });
            
            // Mostrar cada n√∫mero
            memorySequence.forEach((num, index) => {
                memoryTimeout = setTimeout(() => {
                    const cell = memoryGrid[positions[index]];
                    cell.classList.add('flipped');
                    
                    // Ocultar despu√©s de un tiempo
                    setTimeout(() => {
                        cell.classList.remove('flipped');
                        if (index === memorySequence.length - 1) {
                            // √öltimo n√∫mero, permitir al jugador
                            setTimeout(() => {
                                display.textContent = '¬°Ahora pulsa los n√∫meros en orden!';
                                memoryShowing = false;
                            }, 500);
                        }
                    }, 1000);
                }, delay);
                
                delay += 1500; // 1.5 segundos entre n√∫meros
            });
        }
        
        function pulsarCeldaMemoria(index) {
            if (memoryShowing) return;
            
            const cell = memoryGrid[index];
            const back = cell.querySelector('.memory-cell-back');
            const expectedNum = memoryPlayerSequence.length + 1;
            
            // Voltear la celda
            cell.classList.add('flipped');
            
            // Verificar si es correcto
            if (back.textContent === expectedNum.toString()) {
                // Correcto
                cell.classList.add('correct');
                memoryPlayerSequence.push(expectedNum);
                
                setTimeout(() => {
                    cell.classList.remove('correct');
                    
                    // Verificar si complet√≥ la ronda
                    if (memoryPlayerSequence.length === memorySequence.length) {
                        // Ronda completada
                        if (memoryRound >= 15) {
                            completarReto2();
                        } else {
                            memoryRound++;
                            setTimeout(() => {
                                siguienteRondaMemoria();
                            }, 1000);
                        }
                    }
                }, 500);
            } else {
                // Incorrecto
                cell.classList.add('wrong');
                vidas--;
                actualizarVidas();
                addLog(`Secuencia incorrecta. Vidas restantes: ${vidas}`);
                
                setTimeout(() => {
                    cell.classList.remove('wrong');
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        // Reiniciar ronda
                        setTimeout(() => {
                            mostrarSecuenciaMemoria();
                        }, 1000);
                    }
                }, 500);
            }
        }
        
        function completarReto2() {
            clearTimeout(memoryTimeout);
            addLog("Reto 2 completado. Todas las rondas superadas.");
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 2000);
        }
        
        function mostrarReto3() {
            const p = preguntaFinal;
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">RETO 3: Pregunta Final</div>
                    <div class="question">
                        <p><strong>PREGUNTA FINAL:</strong> ${p.pregunta}</p>
                        <input type="text" id="respuesta-final" placeholder="Introduce tu respuesta">
                        <button onclick="verificarRespuestaFinal()">Verificar</button>
                        <button onclick="mostrarPistaFinal()">Usar pista (${3 - pistasUsadas} restantes)</button>
                    </div>
                </div>
            `;
            
            document.getElementById('respuesta-final').focus();
            addLog("Iniciando Reto 3: Pregunta Final");
        }
        
        function verificarRespuestaFinal() {
            const respuesta = document.getElementById('respuesta-final').value.toLowerCase().trim();
            const correcta = preguntaFinal.respuesta.toLowerCase();
            
            if (respuesta === correcta) {
                addLog("Respuesta correcta. Reto final completado.");
                retoActual++;
                setTimeout(() => {
                    mostrarRetoActual();
                }, 2000);
            } else {
                vidas--;
                actualizarVidas();
                addLog(`Respuesta incorrecta. Vidas restantes: ${vidas}`);
                
                if (vidas <= 0) {
                    finDelJuego();
                } else {
                    document.getElementById('respuesta-final').value = '';
                    document.getElementById('respuesta-final').focus();
                }
            }
        }
        
        function mostrarPistaFinal() {
            if (pistasUsadas < 3) {
                pistasUsadas++;
                const pista = document.getElementById('hint');
                pista.textContent = `PISTA: ${preguntaFinal.pista}`;
                pista.classList.add('show');
                addLog(`Pista solicitada: ${preguntaFinal.pista.substring(0, 20)}...`);
                
                setTimeout(() => {
                    pista.classList.remove('show');
                }, 10000);
            }
        }
        
        function mostrarReto4() {
            binaryLevel = 1;
            binaryAttempts = 0;
            stegoRevealed = false;
            
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">RETO 4: L√≥gica Binaria</div>
                    <div class="reto-description">
                        <p>Resuelve las operaciones l√≥gicas binarias para superar este reto.</p>
                        <p>Debes completar 5 niveles de dificultad creciente.</p>
                    </div>
                    <div class="game-area">
                        <div class="binary-container">
                            <div class="binary-level">Nivel: <span id="binary-level">1</span> / 5</div>
                            <div class="binary-attempts">Intentos: <span id="binary-attempts">0</span> / 3</div>
                            <div class="binary-operation" id="binary-operation">Cargando operaci√≥n...</div>
                            <div class="binary-hint" id="binary-hint"></div>
                            <input type="text" id="binary-answer" class="binary-input" placeholder="Respuesta binaria">
                            <button onclick="verificarRespuestaBinaria()">Verificar</button>
                            <div class="progress-bar">
                                <div class="progress" id="progress4"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            generarOperacionBinaria();
            addLog("Iniciando Reto 4: L√≥gica Binaria");
        }
        
        function generarOperacionBinaria() {
            document.getElementById('binary-level').textContent = binaryLevel;
            document.getElementById('binary-attempts').textContent = binaryAttempts;
            
            let operacion, respuesta, pista;
            
            // Generar operaci√≥n seg√∫n el nivel
            switch(binaryLevel) {
                case 1:
                    // Operaci√≥n simple: AND/OR/XOR entre dos n√∫meros
                    const num1 = Math.floor(Math.random() * 8) + 1;
                    const num2 = Math.floor(Math.random() * 8) + 1;
                    const ops = ['AND', 'OR', 'XOR'];
                    const op = ops[Math.floor(Math.random() * ops.length)];
                    
                    operacion = `${num1.toString(2).padStart(3, '0')} ${op} ${num2.toString(2).padStart(3, '0')}`;
                    
                    if (op === 'AND') {
                        respuesta = (num1 & num2).toString(2).padStart(3, '0');
                    } else if (op === 'OR') {
                        respuesta = (num1 | num2).toString(2).padStart(3, '0');
                    } else {
                        respuesta = (num1 ^ num2).toString(2).padStart(3, '0');
                    }
                    
                    pista = "Recuerda: AND=1 solo si ambos bits son 1, OR=1 si al menos un bit es 1, XOR=1 si los bits son diferentes.";
                    break;
                    
                case 2:
                    // Operaci√≥n con NOT
                    const num3 = Math.floor(Math.random() * 16) + 1;
                    operacion = `NOT(${num3.toString(2).padStart(4, '0')})`;
                    respuesta = (~num3 & 0xF).toString(2).padStart(4, '0');
                    pista = "NOT invierte todos los bits: 0‚Üí1 y 1‚Üí0.";
                    break;
                    
                case 3:
                    // Operaci√≥n combinada
                    const num4 = Math.floor(Math.random() * 8) + 1;
                    const num5 = Math.floor(Math.random() * 8) + 1;
                    const num6 = Math.floor(Math.random() * 8) + 1;
                    operacion = `(${num4.toString(2).padStart(3, '0')} AND ${num5.toString(2).padStart(3, '0')}) OR ${num6.toString(2).padStart(3, '0')}`;
                    respuesta = ((num4 & num5) | num6).toString(2).padStart(3, '0');
                    pista = "Resuelve primero la operaci√≥n entre par√©ntesis.";
                    break;
                    
                case 4:
                    // Operaci√≥n con desplazamiento
                    const num7 = Math.floor(Math.random() * 32) + 1;
                    const shift = Math.floor(Math.random() * 3) + 1;
                    const direction = Math.random() < 0.5 ? '<<' : '>>';
                    
                    operacion = `${num7.toString(2).padStart(5, '0')} ${direction} ${shift}`;
                    
                    if (direction === '<<') {
                        respuesta = ((num7 << shift) & 0x1F).toString(2).padStart(5, '0');
                    } else {
                        respuesta = (num7 >> shift).toString(2).padStart(5, '0');
                    }
                    
                    pista = "<< desplaza bits a la izquierda, >> desplaza bits a la derecha.";
                    break;
                    
                case 5:
                    // Operaci√≥n compleja
                    const num8 = Math.floor(Math.random() * 16) + 1;
                    const num9 = Math.floor(Math.random() * 16) + 1;
                    const num10 = Math.floor(Math.random() * 16) + 1;
                    operacion = `NOT(${num8.toString(2).padStart(4, '0')} AND ${num9.toString(2).padStart(4, '0')}) XOR ${num10.toString(2).padStart(4, '0')}`;
                    respuesta = ((~(num8 & num9) & 0xF) ^ num10).toString(2).padStart(4, '0');
                    pista = "Resuelve paso a paso: primero el AND, luego el NOT, finalmente el XOR.";
                    break;
            }
            
            currentBinaryOperation = operacion;
            binaryAnswer = respuesta;
            
            document.getElementById('binary-operation').textContent = operacion + " = ?";
            document.getElementById('binary-hint').textContent = pista;
            document.getElementById('binary-answer').value = '';
            document.getElementById('binary-answer').focus();
            
            updateProgress(4, (binaryLevel - 1) / 5);
        }
        
        function verificarRespuestaBinaria() {
            const respuesta = document.getElementById('binary-answer').value.trim();
            
            if (respuesta === binaryAnswer) {
                addLog(`Respuesta binaria correcta: ${binaryAnswer}`);
                
                if (binaryLevel >= 5) {
                    completarReto4();
                } else {
                    binaryLevel++;
                    binaryAttempts = 0;
                    setTimeout(() => {
                        generarOperacionBinaria();
                    }, 1500);
                }
            } else {
                binaryAttempts++;
                document.getElementById('binary-attempts').textContent = binaryAttempts;
                
                if (binaryAttempts >= maxBinaryAttempts) {
                    vidas--;
                    actualizarVidas();
                    addLog(`M√°ximo de intentos alcanzado. Vidas restantes: ${vidas}`);
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        binaryAttempts = 0;
                        setTimeout(() => {
                            generarOperacionBinaria();
                        }, 1000);
                    }
                } else {
                    addLog(`Respuesta incorrecta. Intentos restantes: ${maxBinaryAttempts - binaryAttempts}`);
                    document.getElementById('binary-answer').value = '';
                    document.getElementById('binary-answer').focus();
                }
            }
        }
        
        function completarReto4() {
            addLog("Reto 4 completado. Todos los niveles de l√≥gica binaria superados.");
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 2000);
        }
        
        function mostrarReto5() {
            stegoAttempts = 0;
            stegoRevealed = false;
            
            // Generar texto con mensaje oculto
            generarTextoEsteganografia();
            
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">RETO 5: Esteganograf√≠a Avanzada</div>
                    <div class="reto-description">
                        <p>Encuentra el mensaje oculto en el siguiente texto usando t√©cnicas de esteganograf√≠a.</p>
                        <p>El mensaje est√° codificado usando m√∫ltiples capas de ocultaci√≥n.</p>
                    </div>
                    <div class="game-area">
                        <div class="stego-container">
                            <div class="stego-attempts">Intentos: <span id="stego-attempts">0</span> / 3</div>
                            <div class="stego-text" id="stego-text">${stegoText}</div>
                            <div class="stego-hint" id="stego-hint">
                                El mensaje est√° oculto usando t√©cnicas avanzadas de esteganograf√≠a.
                                Debes encontrar el patr√≥n binario oculto, convertirlo a colores y reconocer la bandera.
                            </div>
                            <div class="stego-tools">
                                <div class="stego-tool" onclick="revelarPista1()">Pista 1: Binario</div>
                                <div class="stego-tool" onclick="revelarPista2()">Pista 2: Colores</div>
                                <div class="stego-tool" onclick="revelarPista3()">Pista 3: Bandera</div>
                            </div>
                            <div class="stego-colors" id="stego-colors"></div>
                            <input type="text" id="stego-answer" class="stego-input" placeholder="Mensaje oculto">
                            <button onclick="verificarRespuestaEsteganografia()">Verificar</button>
                            <div class="progress-bar">
                                <div class="progress" id="progress5"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('stego-attempts').textContent = stegoAttempts;
            updateProgress(5, 0);
            addLog("Iniciando Reto 5: Esteganograf√≠a Avanzada");
        }
        
        function generarTextoEsteganografia() {
            // Mensaje a ocultar: "Espa√±a"
            stegoMessage = "Espa√±a";
            
            // Convertir el mensaje a binario (cada car√°cter a 8 bits)
            stegoBinary = "";
            for (let i = 0; i < stegoMessage.length; i++) {
                const charCode = stegoMessage.charCodeAt(i);
                stegoBinary += charCode.toString(2).padStart(8, '0');
            }
            
            // Convertir binario a colores (cada 8 bits = 1 byte = 1 color RGB)
            stegoColors = [];
            for (let i = 0; i < stegoBinary.length; i += 8) {
                const byte = stegoBinary.substr(i, 8);
                const decimal = parseInt(byte, 2);
                
                // Mapear el valor decimal a colores de la bandera de Espa√±a
                // Rojo: valores bajos (0-85), Amarillo: valores medios (86-170), Rojo: valores altos (171-255)
                let color;
                if (decimal <= 85) {
                    // Rojo espa√±ol
                    color = `rgb(${170 + Math.floor(decimal / 85 * 85)}, 0, 0)`;
                } else if (decimal <= 170) {
                    // Amarillo espa√±ol
                    const yellowValue = Math.floor((decimal - 86) / 84 * 255);
                    color = `rgb(${yellowValue}, ${yellowValue}, 0)`;
                } else {
                    // Rojo espa√±ol
                    color = `rgb(${170 + Math.floor((decimal - 171) / 84 * 85)}, 0, 0)`;
                }
                
                stegoColors.push(color);
            }
            
            // Texto base con esteganograf√≠a
            const textoBase = `El sistema operativo es la base fundamental de cualquier computadora moderna. 
            Los algoritmos de encriptaci√≥n garantizan la seguridad de los datos transmitidos. 
            La arquitectura de red determina c√≥mo se conectan los dispositivos entre s√≠. 
            Los protocolos de comunicaci√≥n establecen las reglas para el intercambio de informaci√≥n. 
            La inteligencia artificial est√° transformando numerosas industrias. 
            El an√°lisis de datos permite descubrir patrones ocultos en grandes vol√∫menes de informaci√≥n. 
            La realidad virtual crea experiencias inmersivas para los usuarios. 
            La computaci√≥n cu√°ntica promete revolucionar el procesamiento de informaci√≥n.`;
            
            // Ocultar el binario en el texto usando espacios y caracteres invisibles
            let textoConBinario = "";
            let binIndex = 0;
            
            for (let i = 0; i < textoBase.length; i++) {
                const char = textoBase[i];
                textoConBinario += char;
                
                // Insertar bits usando espacios y caracteres invisibles
                if (char === ' ' && binIndex < stegoBinary.length) {
                    if (stegoBinary[binIndex] === '1') {
                        textoConBinario += '  '; // Espacio doble para bit 1
                    } else {
                        textoConBinario += ' '; // Espacio simple para bit 0
                    }
                    binIndex++;
                }
            }
            
            stegoText = textoConBinario;
        }
        
        function revelarPista1() {
            if (!stegoRevealed) {
                document.getElementById('stego-hint').innerHTML = `
                    <strong>Pista 1:</strong> Los espacios dobles representan bits '1' y los espacios simples representan bits '0'.
                    <br><strong>Secuencia binaria:</strong> ${stegoBinary}
                `;
                stegoRevealed = true;
            }
        }
        
        function revelarPista2() {
            if (!stegoRevealed) {
                document.getElementById('stego-hint').innerHTML = `
                    <strong>Pista 2:</strong> Cada grupo de 8 bits forma un byte que representa un color RGB.
                    <br><strong>Valores decimales:</strong> ${stegoBinary.match(/.{1,8}/g).map(byte => parseInt(byte, 2)).join(', ')}
                `;
                stegoRevealed = true;
            }
        }
        
        function revelarPista3() {
            if (!stegoRevealed) {
                // Mostrar los colores
                const colorsContainer = document.getElementById('stego-colors');
                colorsContainer.innerHTML = '';
                
                stegoColors.forEach(color => {
                    const colorBox = document.createElement('div');
                    colorBox.className = 'color-box';
                    colorBox.style.backgroundColor = color;
                    colorsContainer.appendChild(colorBox);
                });
                
                document.getElementById('stego-hint').innerHTML = `
                    <strong>Pista 3:</strong> Los colores forman la bandera de Espa√±a (rojo-amarillo-rojo).
                    <br><strong>Colores RGB:</strong> ${stegoColors.join(', ')}
                `;
                stegoRevealed = true;
            }
        }
        
        function verificarRespuestaEsteganografia() {
            const respuesta = document.getElementById('stego-answer').value.trim();
            
            if (respuesta.toLowerCase() === "espa√±a") {
                addLog("‚úÖ Mensaje esteganogr√°fico correcto");
                completarReto5();
            } else {
                stegoAttempts++;
                document.getElementById('stego-attempts').textContent = stegoAttempts;
                
                if (stegoAttempts >= maxStegoAttempts) {
                    vidas--;
                    actualizarVidas();
                    addLog(`M√°ximo de intentos alcanzado. Vidas restantes: ${vidas}`);
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        stegoAttempts = 0;
                        setTimeout(() => {
                            mostrarReto5();
                        }, 1000);
                    }
                } else {
                    addLog(`Mensaje incorrecto. Intentos restantes: ${maxStegoAttempts - stegoAttempts}`);
                    document.getElementById('stego-answer').value = '';
                    document.getElementById('stego-answer').focus();
                }
            }
        }
        
        function completarReto5() {
            addLog("üéâ Reto 5 completado");
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 2000);
        }
        
        // ============================================
        // RETO 6: LSB Canvas Interactivo
        // ============================================
        
        function mostrarReto6() {
            lsbAttempts = 0;
            lsbExtractedBits = [];
            lsbCurrentPixel = {x: 0, y: 0};
            
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">üî¨ RETO 6: An√°lisis LSB de Imagen</div>
                    <div class="reto-description">
                        <p>Una imagen contiene un mensaje oculto usando esteganograf√≠a LSB (Least Significant Bit).</p>
                        <p>Debes analizar los bits menos significativos de los p√≠xeles para extraer el mensaje secreto.</p>
                        <p style="color: #ff0;">‚ö†Ô∏è Este reto requiere an√°lisis profundo y uso de herramientas avanzadas.</p>
                    </div>
                    
                    <div class="game-area">
                        <div class="lsb-container">
                            <!-- Informaci√≥n de intentos -->
                            <div style="text-align: center; margin-bottom: 20px;">
                                <span style="color: #ff0; font-size: 1.1em;">Intentos: <span id="lsb-attempts">0</span> / 3</span>
                            </div>
                            
                            <!-- Canvas con la imagen -->
                            <div class="lsb-canvas-wrapper">
                                <canvas id="lsb-canvas" width="400" height="100"></canvas>
                            </div>
                            
                            <!-- Informaci√≥n del p√≠xel bajo el cursor -->
                            <div class="pixel-info" id="pixel-info">
                                <div style="text-align: center; color: #ff0; margin-bottom: 10px;">
                                    <strong>üìç Informaci√≥n del P√≠xel</strong>
                                </div>
                                <div class="pixel-info-row">
                                    <span>Posici√≥n:</span>
                                    <span id="pixel-pos">Mueve el cursor sobre la imagen</span>
                                </div>
                                <div class="pixel-info-row">
                                    <span>RGB:</span>
                                    <span id="pixel-rgb">-</span>
                                </div>
                                <div class="pixel-info-row">
                                    <span>Binario R:</span>
                                    <span id="pixel-bin-r" style="font-family: 'Courier New';">-</span>
                                </div>
                                <div class="pixel-info-row">
                                    <span>Binario G:</span>
                                    <span id="pixel-bin-g" style="font-family: 'Courier New';">-</span>
                                </div>
                                <div class="pixel-info-row">
                                    <span>Binario B:</span>
                                    <span id="pixel-bin-b" style="font-family: 'Courier New';">-</span>
                                </div>
                                <div class="pixel-info-row" style="border-top: 2px solid #0f0; margin-top: 5px; padding-top: 5px;">
                                    <span>LSB:</span>
                                    <span id="pixel-lsb" style="color: #ff0; font-weight: bold;">-</span>
                                </div>
                            </div>
                            
                            <!-- Controles de an√°lisis -->
                            <div class="lsb-controls">
                                <div class="lsb-control-panel">
                                    <h3>üîß Herramientas de Extracci√≥n</h3>
                                    <button class="lsb-button" onclick="extraerLSBManual()">
                                        üîç Extraer LSB Manual
                                    </button>
                                    <button class="lsb-button" onclick="extraerLSBAuto()">
                                        ‚ö° Extracci√≥n Autom√°tica
                                    </button>
                                    <button class="lsb-button" onclick="mostrarBinarioCompleto()">
                                        üìä Ver Secuencia Binaria
                                    </button>
                                    <button class="lsb-button" onclick="decodificarASCII()">
                                        üìù Decodificar a ASCII
                                    </button>
                                </div>
                                
                                <div class="lsb-control-panel">
                                    <h3>üé® An√°lisis de Canales</h3>
                                    <button class="lsb-button" onclick="analizarCanal('red')">
                                        üî¥ Canal Rojo
                                    </button>
                                    <button class="lsb-button" onclick="analizarCanal('green')">
                                        üü¢ Canal Verde
                                    </button>
                                    <button class="lsb-button" onclick="analizarCanal('blue')">
                                        üîµ Canal Azul
                                    </button>
                                    <button class="lsb-button" onclick="analizarCanal('all')">
                                        ‚ö™ Todos los Canales
                                    </button>
                                </div>
                                
                                <div class="lsb-control-panel">
                                    <h3>üí° Pistas</h3>
                                    <button class="lsb-button" onclick="mostrarPistaLSB(1)">
                                        üí≠ Pista 1: ¬øQu√© es LSB?
                                    </button>
                                    <button class="lsb-button" onclick="mostrarPistaLSB(2)">
                                        üí≠ Pista 2: Canal correcto
                                    </button>
                                    <button class="lsb-button" onclick="mostrarPistaLSB(3)">
                                        üí≠ Pista 3: Decodificaci√≥n
                                    </button>
                                </div>
                            </div>
                            
                            <!-- An√°lisis de espectro -->
                            <div class="spectrum-analyzer" id="spectrum-analyzer" style="display: none;">
                                <h3 style="color: #ff0; text-align: center; margin-bottom: 15px;">üìä An√°lisis de Canales RGB</h3>
                                <div class="color-channel">
                                    <div>üî¥ Canal Rojo - LSB: <span id="red-lsb-count">0</span> bits extra√≠dos</div>
                                    <div class="channel-bar">
                                        <div class="channel-fill red" id="red-fill" style="width: 0%;"></div>
                                    </div>
                                </div>
                                <div class="color-channel">
                                    <div>üü¢ Canal Verde - LSB: <span id="green-lsb-count">0</span> bits extra√≠dos</div>
                                    <div class="channel-bar">
                                        <div class="channel-fill green" id="green-fill" style="width: 0%;"></div>
                                    </div>
                                </div>
                                <div class="color-channel">
                                    <div>üîµ Canal Azul - LSB: <span id="blue-lsb-count">0</span> bits extra√≠dos</div>
                                    <div class="channel-bar">
                                        <div class="channel-fill blue" id="blue-fill" style="width: 0%;"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Display de binario -->
                            <div class="binary-display" id="binary-display" style="display: none;">
                                <h3 style="color: #ff0; text-align: center; margin-bottom: 10px;">üî¢ Secuencia Binaria Extra√≠da</h3>
                                <div id="binary-content"></div>
                            </div>
                            
                            <!-- Mensaje extra√≠do -->
                            <div id="extracted-message-container"></div>
                            
                            <!-- Crypto hint -->
                            <div class="crypto-hint" id="lsb-hint">
                                <strong>üí° Informaci√≥n:</strong> El mensaje est√° oculto en los bits menos significativos (LSB) de los p√≠xeles.
                                Cada p√≠xel RGB tiene 3 bytes, y cada byte tiene 8 bits. El LSB es el bit en la posici√≥n 0 (el √∫ltimo).
                            </div>
                            
                            <!-- Input de respuesta -->
                            <div style="text-align: center; margin-top: 20px;">
                                <input type="text" id="lsb-answer" placeholder="Introduce el mensaje oculto" 
                                       style="width: 300px; text-align: center; font-size: 1.1em; padding: 10px;">
                                <br>
                                <button onclick="verificarRespuestaLSB()" style="margin-top: 10px; padding: 10px 30px; font-size: 1.1em;">
                                    ‚úÖ Verificar Respuesta
                                </button>
                            </div>
                            
                            <!-- Barra de progreso -->
                            <div class="progress-bar">
                                <div class="progress" id="progress6"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar canvas
            setTimeout(() => {
                inicializarCanvasLSB();
            }, 100);
            
            updateProgress(6, 0);
            addLog("Iniciando Reto 6: An√°lisis LSB de Imagen");
        }
        
        function inicializarCanvasLSB() {
            lsbCanvas = document.getElementById('lsb-canvas');
            lsbCtx = lsbCanvas.getContext('2d');
            
            // Generar imagen con mensaje oculto en LSB
            generarImagenConLSB();
            
            // Event listeners para el canvas
            lsbCanvas.addEventListener('mousemove', actualizarInfoPixel);
            lsbCanvas.addEventListener('click', marcarPixel);
        }
        
        function generarImagenConLSB() {
            const width = lsbCanvas.width;
            const height = lsbCanvas.height;
            
            // Crear ImageData
            lsbImageData = lsbCtx.createImageData(width, height);
            const data = lsbImageData.data;
            
            // Mensaje a ocultar: "SIMULACION"
            lsbMessage = "SIMULACION";
            
            // Convertir mensaje a binario
            let binaryMessage = "";
            for (let i = 0; i < lsbMessage.length; i++) {
                const charCode = lsbMessage.charCodeAt(i);
                binaryMessage += charCode.toString(2).padStart(8, '0');
            }
            
            // A√±adir marcador de fin
            binaryMessage += "00000000";
            
            let bitIndex = 0;
            
            // Llenar p√≠xeles con colores aleatorios y ocultar mensaje en LSB del canal verde
            for (let i = 0; i < data.length; i += 4) {
                // Generar colores aleatorios
                const r = Math.floor(Math.random() * 256);
                const g = Math.floor(Math.random() * 256);
                const b = Math.floor(Math.random() * 256);
                
                // Asignar colores
                data[i] = r;         // R
                data[i + 2] = b;     // B
                data[i + 3] = 255;   // A (alpha)
                
                // Ocultar bit en el canal verde (LSB)
                if (bitIndex < binaryMessage.length) {
                    const bit = parseInt(binaryMessage[bitIndex]);
                    // Modificar el LSB del canal verde
                    data[i + 1] = (g & 0xFE) | bit; // Limpiar LSB y poner el bit del mensaje
                    bitIndex++;
                } else {
                    data[i + 1] = g;
                }
            }
            
            // Dibujar imagen en canvas
            lsbCtx.putImageData(lsbImageData, 0, 0);
            
            addLog("Imagen generada para an√°lisis LSB");
        }
        
        function actualizarInfoPixel(e) {
            const rect = lsbCanvas.getBoundingClientRect();
            const x = Math.floor(e.clientX - rect.left);
            const y = Math.floor(e.clientY - rect.top);
            
            if (x >= 0 && x < lsbCanvas.width && y >= 0 && y < lsbCanvas.height) {
                const pixelData = lsbCtx.getImageData(x, y, 1, 1).data;
                const r = pixelData[0];
                const g = pixelData[1];
                const b = pixelData[2];
                
                // Actualizar informaci√≥n
                document.getElementById('pixel-pos').textContent = `(${x}, ${y})`;
                document.getElementById('pixel-rgb').textContent = `R:${r} G:${g} B:${b}`;
                document.getElementById('pixel-bin-r').textContent = r.toString(2).padStart(8, '0');
                document.getElementById('pixel-bin-g').textContent = g.toString(2).padStart(8, '0');
                document.getElementById('pixel-bin-b').textContent = b.toString(2).padStart(8, '0');
                
                // Mostrar LSB de cada canal
                const lsbR = r & 1;
                const lsbG = g & 1;
                const lsbB = b & 1;
                document.getElementById('pixel-lsb').textContent = `R:${lsbR} G:${lsbG} B:${lsbB}`;
                
                lsbCurrentPixel = {x, y};
            }
        }
        
        function marcarPixel(e) {
            const rect = lsbCanvas.getBoundingClientRect();
            const x = Math.floor(e.clientX - rect.left);
            const y = Math.floor(e.clientY - rect.top);
            
            // Dibujar un peque√±o c√≠rculo en el p√≠xel seleccionado
            lsbCtx.strokeStyle = '#ff0';
            lsbCtx.lineWidth = 2;
            lsbCtx.strokeRect(x - 2, y - 2, 4, 4);
            
            addLog(`P√≠xel marcado en (${x}, ${y})`);
        }
        
        function extraerLSBManual() {
            addLog("Extracci√≥n manual LSB iniciada...");
            
            const data = lsbImageData.data;
            let extractedBits = "";
            
            // Extraer LSB del canal verde de los primeros 100 p√≠xeles
            for (let i = 0; i < Math.min(400, data.length / 4); i++) {
                const pixelIndex = i * 4;
                const g = data[pixelIndex + 1];
                const lsb = g & 1;
                extractedBits += lsb;
            }
            
            lsbExtractedBits = extractedBits;
            
            // Mostrar primeros bits
            document.getElementById('lsb-hint').innerHTML = `
                <strong>üìä Extracci√≥n Manual:</strong><br>
                Primeros 80 bits del canal verde: <span style="font-family: 'Courier New'; color: #ff0;">${extractedBits.substring(0, 80)}</span>
                <br><br>
                <strong>üí° Nota:</strong> Agrupa los bits en grupos de 8 para formar bytes, luego convierte a ASCII.
            `;
            
            updateProgress(6, 0.25);
            addLog(`Extra√≠dos ${extractedBits.length} bits del canal verde`);
        }
        
        function extraerLSBAuto() {
            addLog("Extracci√≥n autom√°tica LSB iniciada...");
            
            const data = lsbImageData.data;
            let extractedBits = "";
            
            // Extraer LSB del canal verde de todos los p√≠xeles
            for (let i = 1; i < data.length; i += 4) {
                const lsb = data[i] & 1;
                extractedBits += lsb;
            }
            
            lsbExtractedBits = extractedBits;
            
            // Mostrar an√°lisis de canales
            document.getElementById('spectrum-analyzer').style.display = 'block';
            document.getElementById('green-lsb-count').textContent = extractedBits.length;
            document.getElementById('green-fill').style.width = '100%';
            
            updateProgress(6, 0.5);
            addLog(`Extracci√≥n autom√°tica completada: ${extractedBits.length} bits`);
        }
        
        function mostrarBinarioCompleto() {
            if (lsbExtractedBits.length === 0) {
                addLog("‚ö†Ô∏è Primero debes extraer los bits LSB");
                return;
            }
            
            const binaryDisplay = document.getElementById('binary-display');
            const binaryContent = document.getElementById('binary-content');
            
            binaryDisplay.style.display = 'block';
            binaryContent.innerHTML = '';
            
            // Mostrar bits en grupos de 8
            for (let i = 0; i < Math.min(160, lsbExtractedBits.length); i += 8) {
                const byte = lsbExtractedBits.substring(i, i + 8).padEnd(8, '0');
                const decimal = parseInt(byte, 2);
                const char = decimal > 0 ? String.fromCharCode(decimal) : '?';
                
                const row = document.createElement('div');
                row.className = 'binary-row';
                row.innerHTML = `
                    <span style="color: #0f0;">Byte ${i/8}:</span>
                    ${byte.split('').map((bit, idx) => 
                        `<span class="binary-bit ${bit === '1' ? 'one' : ''}">${bit}</span>`
                    ).join('')}
                    <span style="color: #ff0; margin-left: 10px;">= ${decimal} (${char})</span>
                `;
                binaryContent.appendChild(row);
            }
            
            updateProgress(6, 0.75);
            addLog("Secuencia binaria visualizada");
        }
        
        function decodificarASCII() {
            if (lsbExtractedBits.length === 0) {
                addLog("‚ö†Ô∏è Primero debes extraer los bits LSB");
                return;
            }
            
            let mensaje = "";
            
            // Convertir bits a caracteres
            for (let i = 0; i < lsbExtractedBits.length; i += 8) {
                const byte = lsbExtractedBits.substring(i, i + 8);
                if (byte.length === 8) {
                    const decimal = parseInt(byte, 2);
                    if (decimal === 0) break; // Fin del mensaje
                    if (decimal >= 32 && decimal <= 126) {
                        mensaje += String.fromCharCode(decimal);
                    }
                }
            }
            
            // Mostrar mensaje
            const container = document.getElementById('extracted-message-container');
            container.innerHTML = `
                <div class="lsb-extracted-message">
                    <div style="font-size: 1.5em; color: #ff0; margin-bottom: 10px;">üéâ MENSAJE EXTRA√çDO</div>
                    <div style="font-size: 2em; color: #0f0; font-weight: bold; letter-spacing: 3px;">
                        ${mensaje}
                    </div>
                    <div style="margin-top: 10px; font-size: 0.9em; color: #aaa;">
                        Introduce este mensaje en el campo de respuesta
                    </div>
                </div>
            `;
            
            updateProgress(6, 0.9);
            addLog("Mensaje ASCII decodificado exitosamente");
        }
        
        function analizarCanal(canal) {
            const data = lsbImageData.data;
            let channelBits = "";
            let channelIndex;
            
            switch(canal) {
                case 'red':
                    channelIndex = 0;
                    addLog("Analizando canal ROJO...");
                    break;
                case 'green':
                    channelIndex = 1;
                    addLog("Analizando canal VERDE...");
                    break;
                case 'blue':
                    channelIndex = 2;
                    addLog("Analizando canal AZUL...");
                    break;
                case 'all':
                    addLog("Analizando TODOS los canales...");
                    break;
            }
            
            if (canal !== 'all') {
                for (let i = channelIndex; i < data.length; i += 4) {
                    channelBits += (data[i] & 1);
                }
                
                const mensaje = extraerMensajeDebits(channelBits);
                addLog(`Canal ${canal}: ${channelBits.length} bits extra√≠dos`);
            } else {
                // Analizar todos
                const rBits = extraerCanalBits(data, 0);
                const gBits = extraerCanalBits(data, 1);
                const bBits = extraerCanalBits(data, 2);
                
                addLog(`An√°lisis completo de canales RGB realizado`);
            }
            
            document.getElementById('spectrum-analyzer').style.display = 'block';
        }
        
        function extraerCanalBits(data, channelIndex) {
            let bits = "";
            for (let i = channelIndex; i < data.length; i += 4) {
                bits += (data[i] & 1);
            }
            return bits;
        }
        
        function extraerMensajeDebits(bits) {
            let mensaje = "";
            for (let i = 0; i < bits.length && i < 800; i += 8) {
                const byte = bits.substring(i, i + 8);
                if (byte.length === 8) {
                    const decimal = parseInt(byte, 2);
                    if (decimal === 0) break;
                    if (decimal >= 32 && decimal <= 126) {
                        mensaje += String.fromCharCode(decimal);
                    }
                }
            }
            return mensaje;
        }
        
        function mostrarPistaLSB(numero) {
            const hints = {
                1: `<strong>üí° Pista 1 - ¬øQu√© es LSB?</strong><br>
                    LSB (Least Significant Bit) es el bit menos significativo de un byte. En un byte de 8 bits,
                    es el bit en la posici√≥n 0 (el √∫ltimo). Por ejemplo, en el n√∫mero binario 10110101, el LSB es 1.<br>
                    <strong>En esteganograf√≠a:</strong> Se modifican los LSBs de los p√≠xeles para ocultar informaci√≥n sin
                    cambiar visiblemente la imagen.`,
                
                2: `<strong>üí° Pista 2 - Canal Correcto</strong><br>
                    El mensaje est√° oculto en el <span style="color: #0f0; font-weight: bold;">canal VERDE</span> de la imagen.<br>
                    Cada p√≠xel tiene 3 valores (R, G, B). Debes extraer el LSB del valor G de cada p√≠xel.<br>
                    <strong>Consejo:</strong> Usa la herramienta "Extraer LSB Manual" o "Extracci√≥n Autom√°tica".`,
                
                3: `<strong>üí° Pista 3 - Decodificaci√≥n</strong><br>
                    Una vez extra√≠dos los bits, agr√∫palos de 8 en 8 para formar bytes.<br>
                    Cada byte representa un c√≥digo ASCII de un car√°cter.<br>
                    El mensaje termina cuando encuentres un byte con valor 0 (00000000).<br>
                    <strong>Respuesta:</strong> La palabra que debes introducir tiene 10 letras y comienza con "S".`
            };
            
            document.getElementById('lsb-hint').innerHTML = hints[numero];
            addLog(`Pista ${numero} revelada`);
        }
        
        function verificarRespuestaLSB() {
            const respuesta = document.getElementById('lsb-answer').value.trim().toUpperCase();
            
            if (respuesta === lsbMessage.toUpperCase()) {
                addLog("‚úÖ Respuesta correcta");
                completarReto6();
            } else {
                lsbAttempts++;
                document.getElementById('lsb-attempts').textContent = lsbAttempts;
                
                if (lsbAttempts >= maxLsbAttempts) {
                    vidas--;
                    actualizarVidas();
                    addLog(`‚ùå M√°ximo de intentos alcanzado. Vidas restantes: ${vidas}`);
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        lsbAttempts = 0;
                        setTimeout(() => {
                            mostrarReto6();
                        }, 1000);
                    }
                } else {
                    addLog(`‚ùå Respuesta incorrecta. Intentos restantes: ${maxLsbAttempts - lsbAttempts}`);
                    document.getElementById('lsb-answer').value = '';
                    document.getElementById('lsb-answer').focus();
                }
            }
        }
        
        function completarReto6() {
            updateProgress(6, 1);
            addLog("üéâ Reto 6 completado exitosamente");
            
            document.getElementById('question-container').innerHTML += `
                <div style="text-align: center; margin-top: 30px; padding: 20px; background: rgba(0, 100, 0, 0.3); border: 2px solid #0f0; border-radius: 10px;">
                    <h2 style="color: #0f0;">‚úÖ RETO 6 COMPLETADO</h2>
                    <p style="font-size: 1.2em;">Has dominado el an√°lisis LSB de im√°genes.</p>
                    <p>Preparando siguiente reto...</p>
                </div>
            `;
            
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 3000);
        }
        
        // ============================================
        // RETO 7: Criptograma Multi-Capa
        // ============================================
        
        function mostrarReto7() {
            cryptoAttempts = 0;
            currentCryptoLayer = 0;
            cryptoCompletedLayers = [];
            
            // Definir las capas de cifrado
            cryptoLayers = [
                {
                    nombre: "Capa 1: Cifrado C√©sar",
                    tipo: "caesar",
                    shift: 13,
                    textoOriginal: "PBAGVAHN RA RY FVTHVRAGR, INF OVRA",
                    respuesta: "CONTINUA EN EL SIGUIENTE, VAS BIEN",
                    descripcion: "Un cifrado C√©sar con desplazamiento ROT13",
                    pista: "El desplazamiento es 13. Tambi√©n conocido como ROT13."
                },
                {
                    nombre: "Capa 2: Cifrado Vigen√®re",
                    tipo: "vigenere",
                    clave: "CLAVE",
                    textoOriginal: "YQP MZH XP RFV BJHQDZEK, XLSVA FVU",
                    respuesta: "VEO QUE LO VAS PILLANDO, SIGUE ASI",
                    descripcion: "Cifrado Vigen√®re con clave secreta",
                    pista: "La clave es: CLAVE (literalmente)"
                },
                {
                    nombre: "Capa 3: Base64",
                    tipo: "base64",
                    textoOriginal: "U29sbyBxdWVkYSB1bmEsIGFuaW1v",
                    respuesta: "SOLO QUEDA UNA, ANIMO",
                    descripcion: "Texto codificado en Base64",
                    pista: "Decodifica directamente desde Base64 a texto"
                },
                {
                    nombre: "Capa Final: Cifrado C√©sar ROT7",
                    tipo: "caesar_final",
                    textoOriginal: "JVUZLNBPKV, SV OHZ JVTWSLAOHKV, HUPTV LU LS ZPNBPLUAL YLAV",
                    respuesta: "CONSEGUIDO, LO HAS COMPLETADO, ANIMO EN EL SIGUIENTE RETO",
                    descripcion: "Cifrado C√©sar con desplazamiento secreto",
                    pista: "Prueba diferentes desplazamientos. El desplazamiento es 7 (ROT7)."
                }
            ];
            
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">üîê RETO 7: Criptograma Multi-Capa</div>
                    <div class="reto-description">
                        <p>Debes descifrar 4 capas de cifrado de complejidad creciente.</p>
                        <p>Cada capa desbloqueada te dar√° una pista para la siguiente.</p>
                        <p style="color: #ff0;">‚ö†Ô∏è Usa an√°lisis de frecuencias, tablas de sustituci√≥n y herramientas de descifrado.</p>
                    </div>
                    
                    <div class="game-area">
                        <div class="crypto-container">
                            <!-- Informaci√≥n de intentos -->
                            <div style="text-align: center; margin-bottom: 20px;">
                                <span style="color: #ff0; font-size: 1.1em;">
                                    Capa actual: <span id="crypto-current-layer">1</span> / 4 | 
                                    Intentos: <span id="crypto-attempts">0</span> / 3
                                </span>
                            </div>
                            
                            <!-- Capas de cifrado -->
                            <div class="crypto-layers" id="crypto-layers-container">
                                <!-- Las capas se generar√°n din√°micamente -->
                            </div>
                            
                            <!-- Barra de progreso -->
                            <div class="progress-bar">
                                <div class="progress" id="progress7"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Generar las capas
            setTimeout(() => {
                generarCapasCripto();
            }, 100);
            
            updateProgress(7, 0);
            addLog("Iniciando Reto 7: Criptograma Multi-Capa");
        }
        
        function generarCapasCripto() {
            const container = document.getElementById('crypto-layers-container');
            container.innerHTML = '';
            
            cryptoLayers.forEach((capa, index) => {
                const isLocked = index > currentCryptoLayer;
                const isCompleted = cryptoCompletedLayers.includes(index);
                const isActive = index === currentCryptoLayer;
                
                let statusClass = 'locked';
                let statusText = 'üîí BLOQUEADA';
                
                if (isCompleted) {
                    statusClass = 'completed';
                    statusText = '‚úÖ COMPLETADA';
                } else if (isActive) {
                    statusClass = 'unlocked';
                    statusText = 'üîì ACTIVA';
                }
                
                const capaDiv = document.createElement('div');
                capaDiv.className = `crypto-layer ${isLocked ? 'locked' : ''} ${isCompleted ? 'completed' : ''}`;
                capaDiv.innerHTML = `
                    <div class="layer-header">
                        <div class="layer-title">${capa.nombre}</div>
                        <div class="layer-status ${statusClass}">${statusText}</div>
                    </div>
                    
                    ${!isLocked ? `
                        <div class="encrypted-text">${capa.textoOriginal}</div>
                        
                        <div style="margin: 15px 0;">
                            <strong>üìù Descripci√≥n:</strong> ${capa.descripcion}
                        </div>
                        
                        ${isActive && !isCompleted ? `
                            <div style="margin: 15px 0;">
                                <button class="lsb-button" onclick="mostrarPistaCripto(${index})">üí° Mostrar Pista</button>
                            </div>
                            
                            <div class="crypto-hint" id="crypto-hint-${index}" style="display: none;">
                                ${capa.pista}
                            </div>
                            
                            <div style="text-align: center; margin-top: 15px;">
                                <input type="text" id="crypto-answer-${index}" placeholder="Texto descifrado" 
                                       style="width: 70%; padding: 10px; text-align: center;">
                                <br>
                                <button onclick="verificarCapaCripto(${index})" 
                                        style="margin-top: 10px; padding: 10px 30px;">
                                    ‚úÖ Verificar Capa ${index + 1}
                                </button>
                            </div>
                        ` : ''}
                        
                        ${isCompleted ? `
                            <div style="text-align: center; padding: 15px; background: rgba(50,50,0,0.3); border: 1px solid #ff0; border-radius: 5px;">
                                <strong style="color: #ff0;">‚úÖ RESPUESTA CORRECTA:</strong> 
                                <span style="color: #0f0; font-size: 1.1em;">${capa.respuesta}</span>
                            </div>
                        ` : ''}
                    ` : `
                        <div style="text-align: center; padding: 30px; color: #666;">
                            üîí Completa la capa anterior para desbloquear
                        </div>
                    `}
                `;
                
                container.appendChild(capaDiv);
                
                // A√±adir conector visual entre capas
                if (index < cryptoLayers.length - 1) {
                    const connector = document.createElement('div');
                    connector.className = 'layer-connections';
                    connector.innerHTML = isCompleted ? '‚úÖ ‚¨áÔ∏è' : 'üîí ‚¨áÔ∏è';
                    container.appendChild(connector);
                }
            });
            
            document.getElementById('crypto-current-layer').textContent = currentCryptoLayer + 1;
        }
        
        function mostrarPistaCripto(index) {
            const hintElement = document.getElementById(`crypto-hint-${index}`);
            if (hintElement) {
                hintElement.style.display = 'block';
                addLog(`Pista revelada para Capa ${index + 1}`);
            }
        }
        
        function verificarCapaCripto(index) {
            const inputElement = document.getElementById(`crypto-answer-${index}`);
            if (!inputElement) return;
            
            const respuesta = inputElement.value.trim().toUpperCase().replace(/\s+/g, ' ');
            const respuestaCorrecta = cryptoLayers[index].respuesta.toUpperCase().replace(/\s+/g, ' ');
            
            // Permitir cierta flexibilidad en la respuesta
            const similitud = calcularSimilitud(respuesta, respuestaCorrecta);
            
            if (similitud > 0.8 || respuesta === respuestaCorrecta) {
                addLog(`‚úÖ Capa ${index + 1} descifrada correctamente`);
                cryptoCompletedLayers.push(index);
                currentCryptoLayer++;
                
                const progreso = (currentCryptoLayer / cryptoLayers.length);
                updateProgress(7, progreso);
                
                // Verificar si es la √∫ltima capa
                if (currentCryptoLayer >= cryptoLayers.length) {
                    completarReto7();
                } else {
                    // Regenerar capas para mostrar la siguiente
                    generarCapasCripto();
                    addLog(`üîì Capa ${currentCryptoLayer + 1} desbloqueada`);
                }
            } else {
                cryptoAttempts++;
                document.getElementById('crypto-attempts').textContent = cryptoAttempts;
                
                if (cryptoAttempts >= maxCryptoAttempts) {
                    vidas--;
                    actualizarVidas();
                    addLog(`‚ùå M√°ximo de intentos alcanzado. Vidas restantes: ${vidas}`);
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        cryptoAttempts = 0;
                        setTimeout(() => {
                            mostrarReto7();
                        }, 1000);
                    }
                } else {
                    addLog(`‚ùå Respuesta incorrecta para Capa ${index + 1}. Intentos: ${cryptoAttempts}/${maxCryptoAttempts}`);
                    if (similitud > 0.5) {
                        addLog(`üí° Est√°s cerca... Revisa la ortograf√≠a y espacios`);
                    }
                    inputElement.value = '';
                    inputElement.focus();
                }
            }
        }
        
        function calcularSimilitud(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const editDistance = calcularDistanciaEdicion(longer, shorter);
            return (longer.length - editDistance) / longer.length;
        }
        
        function calcularDistanciaEdicion(str1, str2) {
            const costs = [];
            for (let i = 0; i <= str1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= str2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else if (j > 0) {
                        let newValue = costs[j - 1];
                        if (str1.charAt(i - 1) !== str2.charAt(j - 1)) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
                if (i > 0) costs[str2.length] = lastValue;
            }
            return costs[str2.length];
        }
        
        // Herramientas de descifrado
        function decodificarBase64Tool() {
            const input = document.getElementById('base64-input').value.trim();
            try {
                const decoded = atob(input);
                document.getElementById('base64-output').textContent = decoded;
                addLog(`Base64 decodificado: ${decoded.substring(0, 50)}...`);
            } catch (e) {
                document.getElementById('base64-output').textContent = '‚ùå Error: No es Base64 v√°lido';
                addLog('Error al decodificar Base64');
            }
        }
        
        function descifrarCesarTool() {
            const input = document.getElementById('caesar-input').value.toUpperCase();
            const shift = parseInt(document.getElementById('caesar-shift').value) || 13;
            
            let resultado = '';
            for (let i = 0; i < input.length; i++) {
                const char = input[i];
                if (char >= 'A' && char <= 'Z') {
                    const code = ((char.charCodeAt(0) - 65 - shift + 26) % 26) + 65;
                    resultado += String.fromCharCode(code);
                } else {
                    resultado += char;
                }
            }
            
            document.getElementById('caesar-output').textContent = resultado;
            addLog(`C√©sar descifrado (shift ${shift})`);
        }
        
        function descifrarVigenereTool() {
            const input = document.getElementById('vigenere-input').value.toUpperCase().replace(/[^A-Z]/g, '');
            const key = document.getElementById('vigenere-key').value.toUpperCase().replace(/[^A-Z]/g, '');
            
            if (!key) {
                document.getElementById('vigenere-output').textContent = '‚ùå Introduce una clave';
                return;
            }
            
            let resultado = '';
            for (let i = 0, j = 0; i < input.length; i++) {
                const charCode = input.charCodeAt(i);
                if (charCode >= 65 && charCode <= 90) {
                    const keyChar = key.charCodeAt(j % key.length) - 65;
                    const decrypted = ((charCode - 65 - keyChar + 26) % 26) + 65;
                    resultado += String.fromCharCode(decrypted);
                    j++;
                } else {
                    resultado += input[i];
                }
            }
            
            document.getElementById('vigenere-output').textContent = resultado;
            addLog("Vigen√®re descifrado exitosamente");
        }
        
        function analizarFrecuencias() {
            const text = document.getElementById('freq-text-input').value.toUpperCase().replace(/[^A-Z]/g, '');
            
            if (!text) {
                addLog('‚ö†Ô∏è Introduce un texto para analizar');
                return;
            }
            
            // Contar frecuencias
            const freq = {};
            for (let char of text) {
                freq[char] = (freq[char] || 0) + 1;
            }
            
            // Convertir a array y ordenar
            const sortedFreq = Object.entries(freq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15); // Top 15
            
            // Calcular m√°ximo para normalizar
            const maxFreq = sortedFreq[0][1];
            
            // Generar gr√°fico
            const chart = document.getElementById('freq-chart');
            chart.innerHTML = '';
            
            sortedFreq.forEach(([char, count]) => {
                const height = (count / maxFreq) * 100;
                const percentage = ((count / text.length) * 100).toFixed(1);
                
                const bar = document.createElement('div');
                bar.className = 'freq-bar';
                bar.style.height = `${height}%`;
                bar.innerHTML = `
                    <div class="freq-label">${char}</div>
                    <div class="freq-value">${count} (${percentage}%)</div>
                `;
                chart.appendChild(bar);
            });
            
            addLog(`An√°lisis de frecuencias completado: ${text.length} caracteres analizados`);
        }
        
        function completarReto7() {
            updateProgress(7, 1);
            addLog("üéâ Reto 7 completado. Todas las capas descifradas.");
            
            document.getElementById('crypto-layers-container').innerHTML += `
                <div style="text-align: center; margin-top: 30px; padding: 30px; background: rgba(0, 100, 0, 0.3); border: 2px solid #0f0; border-radius: 10px;">
                    <h2 style="color: #0f0; font-size: 2em;">üèÜ RETO 7 COMPLETADO</h2>
                    <p style="font-size: 1.3em; margin: 20px 0;">Has dominado el arte de la criptograf√≠a cl√°sica.</p>
                    <p style="color: #ff0;">Todas las capas han sido descifradas con √©xito.</p>
                    <p style="margin-top: 20px;">Preparando capa final de seguridad...</p>
                </div>
            `;
            
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 4000);
        }
        
        function mostrarCapaFinal() {
            securityStep = 1;
            securityAttempts = 0;
            
            // Mensaje cifrado final - HEX correcto: "STARLIGHT CREPTUDO" 
            securityMessage = "4D5559204249454E2050414E5445524954412C20534947554520415349";
            
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">CAPA FINAL DE SEGURIDAD</div>
                    <div class="reto-description">
                        <p>Has superado todos los retos, pero a√∫n debes descifrar el mensaje final.</p>
                        <p>Este es el √∫ltimo obst√°culo antes de obtener el acceso completo.</p>
                    </div>
                    <div class="game-area">
                        <div class="final-security">
                            <div class="security-step">Paso: <span id="security-step">1</span> / 4</div>
                            <div class="security-attempts">Intentos: <span id="security-attempts">0</span> / 3</div>
                            
                            <div class="security-text" id="security-text">
                                ${securityMessage}
                            </div>
                            
                            <div class="security-hint" id="security-hint">
                                <strong>Pista inicial:</strong> El mensaje est√° codificado en hexadecimal. 
                                Convi√©rtelo a texto para continuar.
                            </div>
                            
                            <div class="security-tools">
                                <div class="tool-row">
                                    <label>Resultado:</label>
                                    <input type="text" id="security-result" placeholder="Introduce el resultado">
                                </div>
                            </div>
                            
                            <button onclick="verificarPasoSeguridad()">Verificar</button>
                            
                            <div class="book-excerpt" id="book-excerpt" style="display: none;">
                                <!-- El extracto del libro se mostrar√° aqu√≠ -->
                            </div>
                            
                            <div class="progress-bar">
                                <div class="progress" id="progress6"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('security-attempts').textContent = securityAttempts;
            updateProgress(6, 0);
            addLog("Iniciando Capa Final de Seguridad");
        }
        
        function verificarPasoSeguridad() {
            const resultado = document.getElementById('security-result').value.trim();
            let correcto = false;
            
            switch(securityStep) {
                case 1:
                    // Paso 1: Hexadecimal a texto - Respuesta: "STARDIHT CREPTUD"
                    if (resultado.toUpperCase() === "MUY BIEN PANTERITA, SIGUE ASI" || resultado.toUpperCase() === "STARDIGHT CREPTUD") {
                        correcto = true;
                        securityStep++;
                        // Base64 de "SIMULACION TEXTO CLAVE"
                        securityMessage = "Q09OVElOVUEgTExFVkFTIERPUyBZIFFVRURBIFBPQ08=";
                        
                        document.getElementById('security-step').textContent = securityStep;
                        document.getElementById('security-text').textContent = securityMessage;
                        document.getElementById('security-hint').innerHTML = `
                            <strong>Paso 2:</strong> El nuevo mensaje est√° en Base64. 
                            Convi√©rtelo a texto para continuar.
                        `;
                        document.getElementById('security-result').value = '';
                        updateProgress(6, 0.25);
                        
                        addLog("Paso 1 completado: Hexadecimal a texto");
                    }
                    break;
                    
                case 2:
                    // Paso 2: Base64 a texto - Respuesta: "SIMULACION TEXTO CLAVE"
                    if (resultado.toUpperCase() === "CONTINUA LLEVAS DOS Y QUEDA POCO") {
                        correcto = true;
                        securityStep++;
                        securityMessage = "Busca en el libro...";
                        
                        document.getElementById('security-step').textContent = securityStep;
                        document.getElementById('security-text').textContent = securityMessage;
                        document.getElementById('security-hint').innerHTML = `
                            <strong>Paso 3:</strong> La clave est√° en el libro "Simulacros y Simulaci√≥n".
                            <br>P√°gina 42, l√≠nea 3, palabra 5.
                        `;
                        document.getElementById('security-result').value = '';
                        
                        // Mostrar extracto del libro
                        const bookExcerpt = `P√°gina 42:
L√≠nea 1: La simulaci√≥n no es una copia de lo real, sino que reemplaza a lo real.
L√≠nea 2: En la era de la simulaci√≥n, los signos ya no remiten a nada real.
L√≠nea 3: El mapa precede al territorio y genera el territorio. La simulaci√≥n es la realidad.
L√≠nea 4: Hiperrealidad es el resultado de la simulaci√≥n total.
L√≠nea 5: Los modelos generan lo real sin necesidad de referentes externos.`;
                        
                        document.getElementById('book-excerpt').textContent = bookExcerpt;
                        document.getElementById('book-excerpt').style.display = 'block';
                        
                        updateProgress(6, 0.5);
                        
                        addLog("Paso 2 completado: Base64 a texto");
                    }
                    break;
                    
                case 3:
                    // Paso 3: Encontrar palabra del libro - Respuesta: "simulaci√≥n"
                    if (resultado.toLowerCase() === "simulacion" || resultado.toLowerCase() === "simulaci√≥n") {
                        correcto = true;
                        securityStep++;
                        // Base64 de "RECONQUISTA"
                        securityMessage = "UkVDT05RVUlTVEE=";
                        
                        document.getElementById('security-step').textContent = securityStep;
                        document.getElementById('security-text').textContent = securityMessage;
                        document.getElementById('security-hint').innerHTML = `
                            <strong>Paso 4 (Final):</strong> Descifra este √∫ltimo mensaje en Base64.
                            <br>El resultado es la contrase√±a final del sistema.
                        `;
                        document.getElementById('security-result').value = '';
                        updateProgress(6, 0.75);
                        
                        addLog("Paso 3 completado: Clave encontrada en el libro");
                    }
                    break;
                    
                case 4:
                    // Paso 4: Base64 final - Respuesta: "RECONQUISTA"
                    if (resultado.toUpperCase() === "RECONQUISTA") {
                        correcto = true;
                        updateProgress(6, 1);
                        
                        addLog("‚úÖ Capa final de seguridad completada");
                        document.getElementById('security-hint').innerHTML = `
                            <div style="color: #0f0; font-size: 1.3em; text-align: center; margin: 20px 0;">
                                üéâ ¬°ACCESO CONCEDIDO! üéâ
                                <br><br>
                                Has completado todos los desaf√≠os.
                            </div>
                        `;
                        
                        setTimeout(() => {
                            mostrarCompletado();
                        }, 2000);
                    }
                    break;
            }
            
            if (!correcto) {
                securityAttempts++;
                document.getElementById('security-attempts').textContent = securityAttempts;
                
                if (securityAttempts >= maxSecurityAttempts) {
                    vidas--;
                    actualizarVidas();
                    addLog(`M√°ximo de intentos alcanzado. Vidas restantes: ${vidas}`);
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        securityAttempts = 0;
                        setTimeout(() => {
                            mostrarCapaFinal();
                        }, 1000);
                    }
                } else {
                    addLog(`Respuesta incorrecta. Intentos restantes: ${maxSecurityAttempts - securityAttempts}`);
                    document.getElementById('security-result').value = '';
                    document.getElementById('security-result').focus();
                }
            }
        }
        
        function updateProgress(reto, porcentaje) {
            const progress = document.getElementById(`progress${reto}`);
            if (progress) {
                progress.style.width = `${porcentaje * 100}%`;
            }
        }
        
        function mostrarCompletado() {
            document.getElementById('question-container').innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <h2 style="color: #0f0; font-size: 2.5em; margin-bottom: 20px;">‚úÖ ACCESO CONCEDIDO</h2>
                    <p style="font-size: 1.3em; margin: 20px 0;">Has superado todas las capas de seguridad del sistema.</p>
                    <p style="color: #ff0; font-size: 1.2em; margin: 20px 0;">¬°Felicidades por completar el desaf√≠o!</p>
                    <p style="margin-top: 30px; font-size: 1.1em;">Redirigiendo a tu recompensa en <span id="countdown">5</span> segundos...</p>
                    <button onclick="window.location.href='final.html'" style="margin-top: 20px; padding: 15px 40px; font-size: 1.2em; background: #0f0; color: #000; border: none; border-radius: 5px; cursor: pointer;">
                        üéÅ IR AHORA A LA RECOMPENSA
                    </button>
                </div>
            `;
            addLog("‚úÖ Verificaci√≥n completada. Acceso concedido al sistema.");
            
            // Countdown y redirecci√≥n autom√°tica
            let countdown = 5;
            const countdownInterval = setInterval(() => {
                countdown--;
                const countdownElement = document.getElementById('countdown');
                if (countdownElement) {
                    countdownElement.textContent = countdown;
                }
                
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    window.location.href = 'final.html';
                }
            }, 1000);
        }
        
        function finDelJuego() {
            juegoActivo = false;
            clearInterval(dinoGameInterval);
            clearTimeout(memoryTimeout);
            document.removeEventListener('keydown', handleKeyDown);
            
            document.getElementById('question-container').innerHTML = `
                <h2>ACCESO DENEGADO</h2>
                <p>Has bloqueado el sistema al acumular suficientes errores. Reiniciando....</p>
                <button onclick="location.reload()">Reiniciar sistema</button>
            `;
            addLog("Sistema bloqueado. Demasiados intentos fallidos.");
        }
        
        // Funci√≥n para verificar el c√≥digo de desarrollo
        function verificarDevCode() {
            const code = document.getElementById('dev-code').value;
            
            // Determinar qu√© password usar seg√∫n la fase del juego
            let passwordValida = false;
            
            // Password 05973784V: v√°lida hasta el reto 5 (esteganograf√≠a) inclusive
            // Password 05912037W: v√°lida para retos 6 y 7
            if (code === '05973784V' && (preguntaActual < preguntas.length || retoActual <= 4)) {
                passwordValida = true;
                addLog("C√≥digo de desarrollo aceptado [05973784V]. Avanzando...");
            } else if (code === '05912037W' && retoActual >= 5) {
                passwordValida = true;
                addLog("C√≥digo de desarrollo aceptado [05912037W]. Avanzando...");
            } else if (code === '5659448') {
                // C√≥digo maestro (backdoor de desarrollo)
                passwordValida = true;
                addLog("C√≥digo maestro aceptado. Avanzando...");
            }
            
            if (passwordValida) {
                // Si estamos en las preguntas, avanzar a la siguiente pregunta
                if (preguntaActual < preguntas.length) {
                    preguntaActual++;
                    mostrarPregunta();
                } 
                // Si estamos en los retos, avanzar al siguiente reto
                else if (retoActual < 8) {
                    retoActual++;
                    mostrarRetoActual();
                }
                // Si ya completamos todo, mostrar completado
                else {
                    mostrarCompletado();
                }
                
                // Limpiar el campo de c√≥digo
                document.getElementById('dev-code').value = '';
            } else {
                addLog("C√≥digo de desarrollo incorrecto");
            }
        }
        
        // Iniciar el juego cuando el DOM est√© completamente cargado
        document.addEventListener('DOMContentLoaded', function() {
            mostrarPregunta();
            addLog("Sistema listo. Esperando entrada del usuario...");
        });
    </script>
</body>
</html>
