<!DOCTYPE html>
<html>
<head>
    <title>Sistema de Acceso Restringido</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #0f0;
            font-family: 'Source+Code+Pro', monospace;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .terminal {
            border: 2px solid #0f0;
            border-radius: 5px;
            padding: 20px;
            max-width: 800px;
            margin: 20px auto;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .question {
            margin: 15px 0;
            padding: 10px;
            border-left: 3px solid #0f0;
            background: rgba(0, 50, 0, 0.3);
        }
        
        input, button, textarea, select {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 15px;
            margin: 5px;
            font-family: inherit;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        
        .lives {
            display: flex;
            justify-content: center;
            margin: 15px 0;
        }
        
        .life {
            width: 20px;
            height: 20px;
            margin: 0 5px;
            background: #0f0;
            border-radius: 50%;
            transition: all 0.3s;
        }
        
        .life.lost {
            background: #300;
            box-shadow: 0 0 5px #f00;
        }
        
        .hint {
            font-style: italic;
            color: #ff0;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .hint.show {
            opacity: 1;
        }
        
        .log {
            height: 100px;
            overflow-y: auto;
            background: rgba(0, 20, 0, 0.5);
            padding: 10px;
            margin-top: 20px;
            border: 1px solid #0f0;
            font-size: 12px;
        }
        
        .log-entry {
            margin: 2px 0;
        }
        
        .cursor {
            display: inline-block;
            width: 10px;
            height: 20px;
            background: #0f0;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        /* Estilos para los retos */
        .reto-container {
            text-align: center;
            padding: 20px;
        }
        
        .reto-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #ff0;
        }
        
        .reto-description {
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .game-area {
            background: rgba(0, 30, 0, 0.5);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
            min-height: 200px;
            position: relative;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: #0f0;
            width: 0%;
            transition: width 0.5s;
        }
        
        /* Estilos para el juego del dinosaurio */
        .dino-game {
            position: relative;
            height: 250px;
            overflow: hidden;
            border: 1px solid #0f0;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 70%, #8FBC8F 70%, #228B22 100%);
        }
        
        .dino {
            position: absolute;
            bottom: 60px;
            left: 50px;
            width: 50px;
            height: 50px;
            font-size: 40px;
            line-height: 50px;
            text-align: center;
            transition: bottom 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
            transform: scaleX(-1); /* Girar para que mire a la derecha */
        }
        
        .dino.jumping {
            animation: jump 0.8s ease-out;
        }
        
        @keyframes jump {
            0% { bottom: 60px; }
            50% { bottom: 160px; }
            100% { bottom: 60px; }
        }
        
        .dino.running {
            animation: run 0.5s steps(2) infinite;
        }
        
        @keyframes run {
            0% { transform: scaleX(-1) translateX(0); }
            100% { transform: scaleX(-1) translateX(10px); }
        }
        
        .obstacle {
            position: absolute;
            bottom: 60px;
            right: 0;
            font-size: 35px;
            width: 35px;
            height: 35px;
            text-align: center;
            z-index: 5;
        }
        
        .ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 60px;
            background: #228B22;
            z-index: 1;
        }
        
        .mountain {
            position: absolute;
            bottom: 60px;
            width: 0;
            height: 0;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            border-bottom: 100px solid #2E8B57;
            z-index: 2;
        }
        
        .cloud {
            position: absolute;
            color: #fff;
            font-size: 40px;
            animation: cloudMove 20s linear infinite;
            z-index: 3;
        }
        
        @keyframes cloudMove {
            from { right: -100px; }
            to { right: 100%; }
        }
        
        .score {
            font-size: 1.2em;
            margin: 10px 0;
        }
        
        /* Estilos para el juego de memoria secuencial */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        
        .memory-cell {
            width: 60px;
            height: 60px;
            background: #222;
            border: 1px solid #0f0;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            transform-style: preserve-3d;
        }
        
        .memory-cell.flipped {
            transform: rotateY(180deg);
        }
        
        .memory-cell-front, .memory-cell-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
        }
        
        .memory-cell-front {
            background: #222;
            color: #0f0;
        }
        
        .memory-cell-back {
            background: #0a0;
            color: #000;
            transform: rotateY(180deg);
        }
        
        .memory-cell.correct {
            animation: pulse 0.5s;
        }
        
        .memory-cell.wrong {
            animation: shake 0.5s;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1) rotateY(180deg); }
            50% { transform: scale(1.2) rotateY(180deg); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0) rotateY(180deg); }
            25% { transform: translateX(-5px) rotateY(180deg); }
            75% { transform: translateX(5px) rotateY(180deg); }
        }
        
        .round-info {
            font-size: 1.1em;
            margin: 10px 0;
        }
        
        .sequence-display {
            font-size: 1.3em;
            margin: 15px 0;
            min-height: 30px;
        }
        
        /* Estilos para el juego de lógica binaria */
        .binary-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .binary-operation {
            font-size: 1.8em;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            font-family: 'Source Code Pro', monospace;
        }
        
        .binary-input {
            font-size: 1.5em;
            width: 200px;
            text-align: center;
        }
        
        .binary-hint {
            font-style: italic;
            color: #ff0;
            margin: 10px 0;
            font-size: 0.9em;
        }
        
        .binary-level {
            font-size: 1.2em;
            margin: 10px 0;
        }
        
        .binary-attempts {
            font-size: 1em;
            margin: 5px 0;
            color: #aaa;
        }
        
        /* Estilos para el juego de esteganografía */
        .stego-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .stego-text {
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Source Code Pro', monospace;
            line-height: 1.6;
            font-size: 1em;
        }
        
        .stego-hint {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ff0;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-style: italic;
            color: #ff0;
        }
        
        .stego-input {
            width: 300px;
            text-align: center;
            font-size: 1.2em;
        }
        
        .stego-tools {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .stego-tool {
            padding: 8px 12px;
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid #0f0;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .stego-tool:hover {
            background: rgba(0, 100, 0, 0.5);
            box-shadow: 0 0 5px #0f0;
        }
        
        .stego-colors {
            display: flex;
            gap: 5px;
            margin: 15px 0;
            justify-content: center;
        }
        
        .color-box {
            width: 30px;
            height: 30px;
            border: 1px solid #0f0;
            border-radius: 3px;
        }
        
        /* Estilos para la capa final de seguridad */
        .final-security {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .security-text {
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            width: 100%;
            font-family: 'Source Code Pro', monospace;
            line-height: 1.6;
            font-size: 1em;
            word-break: break-all;
        }
        
        .security-tools {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }
        
        .tool-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .tool-row label {
            min-width: 120px;
            text-align: right;
        }
        
        .tool-row input, .tool-row select {
            flex: 1;
        }
        
        .book-excerpt {
            background: rgba(0, 20, 0, 0.5);
            border: 1px dashed #0f0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .security-hint {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ff0;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-style: italic;
            color: #ff0;
        }
        
        /* Panel de desarrollo */
        .dev-panel {
            margin-top: 20px;
            text-align: center;
            padding: 10px;
            border: 1px dashed #0f0;
            border-radius: 5px;
        }
        
        /* Estilos para el Reto 6: LSB Canvas Interactivo */
        .lsb-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        }
        
        .lsb-canvas-wrapper {
            position: relative;
            border: 2px solid #0f0;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
            background: #000;
            padding: 10px;
        }
        
        #lsb-canvas {
            display: block;
            max-width: 100%;
            cursor: crosshair;
            image-rendering: pixelated;
        }
        
        .lsb-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            width: 100%;
            margin: 20px 0;
        }
        
        .lsb-control-panel {
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
        }
        
        .lsb-control-panel h3 {
            color: #ff0;
            margin-bottom: 10px;
            font-size: 1em;
            border-bottom: 1px solid #0f0;
            padding-bottom: 5px;
        }
        
        .lsb-button {
            width: 100%;
            margin: 5px 0;
            padding: 10px;
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid #0f0;
            color: #0f0;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }
        
        .lsb-button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        
        .lsb-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pixel-info {
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 10px;
            font-size: 0.9em;
            margin: 10px 0;
        }
        
        .pixel-info-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px dotted #0f0;
        }
        
        .binary-display {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        
        .binary-row {
            display: flex;
            gap: 10px;
            margin: 5px 0;
            font-size: 0.85em;
        }
        
        .binary-bit {
            padding: 2px 5px;
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid #0f0;
            border-radius: 3px;
            min-width: 20px;
            text-align: center;
        }
        
        .binary-bit.one {
            background: rgba(0, 100, 0, 0.7);
            color: #fff;
        }
        
        .lsb-extracted-message {
            background: rgba(0, 50, 0, 0.7);
            border: 2px solid #ff0;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-size: 1.2em;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px #ff0; }
            50% { box-shadow: 0 0 20px #ff0; }
        }
        
        .spectrum-analyzer {
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .color-channel {
            margin: 10px 0;
        }
        
        .channel-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        .channel-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .channel-fill.red { background: #f00; }
        .channel-fill.green { background: #0f0; }
        .channel-fill.blue { background: #00f; }
        
        /* Estilos para el Reto 7: Criptograma Multi-Capa */
        .crypto-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
        }
        
        .crypto-layers {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }
        
        .crypto-layer {
            background: rgba(0, 30, 0, 0.7);
            border: 2px solid #0f0;
            border-radius: 5px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .crypto-layer.locked {
            opacity: 0.5;
            pointer-events: none;
        }
        
        .crypto-layer.completed {
            border-color: #ff0;
            background: rgba(50, 50, 0, 0.3);
        }
        
        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #0f0;
        }
        
        .layer-title {
            color: #ff0;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .layer-status {
            padding: 5px 10px;
            background: rgba(0, 50, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        .layer-status.unlocked {
            color: #0f0;
        }
        
        .layer-status.locked {
            color: #f00;
        }
        
        .layer-status.completed {
            color: #ff0;
            border-color: #ff0;
        }
        
        .encrypted-text {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            word-break: break-all;
            line-height: 1.6;
            min-height: 60px;
        }
        
        .crypto-tools {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .crypto-tool {
            background: rgba(0, 40, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
        }
        
        .crypto-tool h4 {
            color: #ff0;
            margin-bottom: 10px;
            font-size: 0.95em;
        }
        
        .tool-input-group {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            align-items: center;
        }
        
        .tool-input-group label {
            min-width: 80px;
            font-size: 0.9em;
        }
        
        .tool-input-group input,
        .tool-input-group select {
            flex: 1;
        }
        
        .frequency-analysis {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .freq-chart {
            display: flex;
            align-items: flex-end;
            gap: 3px;
            height: 150px;
            margin: 15px 0;
            border-bottom: 1px solid #0f0;
            padding: 10px;
        }
        
        .freq-bar {
            flex: 1;
            background: #0f0;
            min-width: 15px;
            position: relative;
            transition: height 0.3s;
            cursor: pointer;
        }
        
        .freq-bar:hover {
            background: #ff0;
        }
        
        .freq-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
        }
        
        .freq-value {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7em;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
            white-space: nowrap;
        }
        
        .substitution-table {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .substitution-pair {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0, 40, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 3px;
            padding: 5px;
        }
        
        .substitution-pair input {
            width: 30px;
            text-align: center;
            padding: 3px;
            margin: 0;
        }
        
        .cipher-preview {
            background: rgba(0, 20, 0, 0.9);
            border: 1px dashed #ff0;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
        }
        
        .crypto-hint {
            background: rgba(50, 50, 0, 0.3);
            border: 1px solid #ff0;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-style: italic;
            color: #ff0;
            font-size: 0.9em;
        }
        
        .layer-connections {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            color: #0f0;
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="terminal">
        <div class="header">
            <h1>ACCESO RESTRINGIDO - SISTEMA DE SEGURIDAD NIVEL 3</h1>
            <p>Identificación requerida. 9 preguntas + 5 retos de verificación.</p>
        </div>
        
        <div class="lives" id="lives">
            <div class="life"></div>
            <div class="life"></div>
            <div class="life"></div>
        </div>
        
        <div id="question-container">
            <!-- Las preguntas se cargarán aquí -->
        </div>
        
        <div class="hint" id="hint"></div>
        
        <div class="log" id="log">
            <div class="log-entry">[SYSTEM] Iniciando protocolo de verificación...</div>
        </div>
        
        <!-- Panel de desarrollo -->
        <div class="dev-panel">
            <p>Panel de desarrollo:</p>
            <input type="text" id="dev-code" placeholder="Introduce código">
            <button onclick="verificarDevCode()">Avanzar</button>
        </div>
    </div>

    <script>
        // Base de datos de preguntas
        const preguntas = [
            {
                pregunta: "Como se llama el cangrejo verde de mi casa?",
                respuesta: "Calras",
                pista: "(🦞👳‍♀️)"
            },
            {
                pregunta: "Que me lanzaste en la playa?",
                respuesta: "Patata",
                pista: "(Una sola palabra)"
            },
            {
                pregunta: "Juego que has creado tu",
                respuesta: "Monkey gaming",
                pista: "(Mono)"
            },
            {
                pregunta: "¿Qué entidad invisible y absoluta, que existe sin depender de materia ni energía, fluye siempre en una sola dirección y marca el destino de todo lo que existe?",
                respuesta: "Tiempo",
                pista: "(Una palabra)"
            },
            {
                pregunta: "Que es lo que mas queria Eren",
                respuesta: "Libertad",
                pista: "🐚"
            },
            {
                pregunta: "¿Qué misterio une corazones distantes, desafía al tiempo y a la razón, y brilla incluso en la oscuridad más profunda?",
                respuesta: "Amor",
                pista: " (1 palabra)"
            },
            {
                pregunta: "Cual es el nombre del arma de la enamorada de Gehrman en Bloodborne?",
                respuesta: "Rakuyo",
                pista: "(1 palabra)"
            },
            {
                pregunta: "Quien fue el que 'invento' la Atlantida?",
                respuesta: "Platon",
                pista: "(o primero que la menciono)"
            },
            {
                pregunta: "Quis post finem mundi vivit et novam vitam hominibus affert? (Mythos Nordicus)",
                respuesta: "Líf and Lífþrasir",
                pista: "Ella y El"
            }
        ];
        
        // Pregunta final (será el reto 3)
        const preguntaFinal = {
            pregunta: "Esta es la pregunta 10, ultima, noche en que todo empezo",
            respuesta: "19/03/2019",
            pista: " DD/MM/YYYY"
        };
        
        let preguntaActual = 0;
        let vidas = 3;
        let pistasUsadas = 0;
        let retoActual = 0;
        let juegoActivo = false;
        
        // Variables para el juego del dinosaurio
        let dinoScore = 0;
        let dinoGameInterval;
        let dinoObstacleInterval;
        let dinoJumping = false;
        let gameSpeed = 5;
        let dinoRunning = false;
        let obstacles = [];
        let nextObstacleDistance = 400;
        let doubleObstacleChance = 0.3;
        
        // Variables para el juego de memoria secuencial
        let memoryRound = 1;
        let memorySequence = [];
        let memoryPlayerSequence = [];
        let memoryShowing = false;
        let memoryTimeout;
        let memoryNumbers = [];
        let memoryGrid = [];
        
        // Variables para el juego de lógica binaria
        let binaryLevel = 1;
        let binaryAttempts = 0;
        let maxBinaryAttempts = 3;
        let currentBinaryOperation = null;
        let binaryAnswer = null;
        
        // Variables para el juego de esteganografía
        let stegoAttempts = 0;
        let maxStegoAttempts = 3;
        let stegoMessage = "";
        let stegoText = "";
        let stegoRevealed = false;
        let stegoBinary = "";
        let stegoColors = [];
        
        // Variables para la capa final de seguridad
        let securityStep = 1;
        let securityAttempts = 0;
        let maxSecurityAttempts = 3;
        let securityMessage = "";
        let securityKey = "";
        
        // Variables para el Reto 6: LSB Canvas Interactivo
        let lsbCanvas = null;
        let lsbCtx = null;
        let lsbImageData = null;
        let lsbAttempts = 0;
        let maxLsbAttempts = 3;
        let lsbMessage = "SIMULACION";
        let lsbCurrentPixel = {x: 0, y: 0};
        let lsbExtractedBits = [];
        let lsbAnalysisMode = 'rgb';
        
        // Variables para el Reto 7: Criptograma Multi-Capa
        let cryptoAttempts = 0;
        let maxCryptoAttempts = 3;
        let cryptoLayers = [];
        let currentCryptoLayer = 0;
        let cryptoCompletedLayers = [];
        let cryptoFinalMessage = "RECONQUISTA";
        let caesarShift = 13;
        let vigenereKey = "CLAVE";
        let cryptoFrequencies = {};
        
        function addLog(message) {
            const log = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
        
        function mostrarPregunta() {
            // Si ya se respondieron todas las preguntas, mostrar los retos
            if (preguntaActual >= preguntas.length) {
                mostrarRetos();
                return;
            }
            
            const p = preguntas[preguntaActual];
            document.getElementById('question-container').innerHTML = `
                <div class="question">
                    <p><strong>PREGUNTA ${preguntaActual + 1}/9:</strong> ${p.pregunta}</p>
                    <input type="text" id="respuesta" placeholder="Introduce tu respuesta">
                    <button onclick="verificarRespuesta()">Verificar</button>
                    <button onclick="mostrarPista()">Usar pista (${3 - pistasUsadas} restantes)</button>
                </div>
            `;
            
            document.getElementById('respuesta').focus();
            addLog(`Mostrando pregunta ${preguntaActual + 1}: ${p.pregunta.substring(0, 20)}...`);
        }
        
        function verificarRespuesta() {
            const respuesta = document.getElementById('respuesta').value.toLowerCase().trim();
            const correcta = preguntas[preguntaActual].respuesta.toLowerCase();
            
            if (respuesta === correcta) {
                addLog("Respuesta correcta. Avanzando...");
                preguntaActual++;
                mostrarPregunta();
            } else {
                vidas--;
                actualizarVidas();
                addLog(`Respuesta incorrecta. Vidas restantes: ${vidas}`);
                
                if (vidas <= 0) {
                    document.getElementById('question-container').innerHTML = `
                        <h2>ACCESO DENEGADO</h2>
                        <p>Has bloqueado el sistema al acumular suficientes errores. Reiniciando....</p>
                        <button onclick="location.reload()">Reiniciar sistema</button>
                    `;
                    addLog("Sistema bloqueado. Demasiados intentos fallidos.");
                } else {
                    document.getElementById('respuesta').value = '';
                    document.getElementById('respuesta').focus();
                }
            }
        }
        
        function mostrarPista() {
            if (pistasUsadas < 3) {
                pistasUsadas++;
                const pista = document.getElementById('hint');
                pista.textContent = `PISTA: ${preguntas[preguntaActual].pista}`;
                pista.classList.add('show');
                addLog(`Pista solicitada: ${preguntas[preguntaActual].pista.substring(0, 20)}...`);
                
                setTimeout(() => {
                    pista.classList.remove('show');
                }, 10000);
            }
        }
        
        function actualizarVidas() {
            const elementosVida = document.querySelectorAll('.life');
            elementosVida.forEach((vida, index) => {
                if (index >= vidas) {
                    vida.classList.add('lost');
                }
            });
        }
        
        function mostrarRetos() {
            retoActual = 0;
            mostrarRetoActual();
        }
        
        function mostrarRetoActual() {
            switch(retoActual) {
                case 0:
                    mostrarReto1();
                    break;
                case 1:
                    mostrarReto2();
                    break;
                case 2:
                    mostrarReto3();
                    break;
                case 3:
                    mostrarReto4();
                    break;
                case 4:
                    mostrarReto5();
                    break;
                case 5:
                    mostrarReto6();
                    break;
                case 6:
                    mostrarReto7();
                    break;
                case 7:
                    mostrarCapaFinal();
                    break;
                default:
                    // Todos los retos completados
                    mostrarCompletado();
            }
        }
        
        function mostrarReto1() {
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">RETO 1: Escape del Dinosaurio</div>
                    <div class="reto-description">
                        <p>Alcanza 5000 puntos para superar este reto.</p>
                        <p>Presiona ESPACIO para saltar los obstáculos.</p>
                    </div>
                    <div class="game-area">
                        <div class="dino-game" id="dino-game">
                            <div class="dino" id="dino">🦕</div>
                            <div class="mountain" style="left: 200px;"></div>
                            <div class="mountain" style="left: 400px; height: 80px; border-bottom-width: 80px;"></div>
                            <div class="mountain" style="left: 600px; height: 60px; border-bottom-width: 60px;"></div>
                            <div class="cloud" style="top: 30px; right: 100px;">☁️</div>
                            <div class="cloud" style="top: 60px; right: 300px;">☁️</div>
                            <div class="cloud" style="top: 40px; right: 500px;">☁️</div>
                            <div class="ground"></div>
                        </div>
                        <div class="score">Puntos: <span id="dino-score">0</span> | Velocidad: <span id="game-speed">1</span>x</div>
                        <button id="jump-btn" onclick="saltarDino()">Saltar (ESPACIO)</button>
                        <div class="progress-bar">
                            <div class="progress" id="progress1"></div>
                        </div>
                    </div>
                </div>
            `;
            
            iniciarJuegoDino();
            addLog("Iniciando Reto 1: Escape del Dinosaurio");
            
            // Añadir evento de teclado
            document.addEventListener('keydown', handleKeyDown);
        }
        
        function handleKeyDown(e) {
            if (retoActual === 0 && juegoActivo && e.code === 'Space') {
                e.preventDefault();
                saltarDino();
            }
        }
        
        function iniciarJuegoDino() {
            dinoScore = 0;
            gameSpeed = 5;
            juegoActivo = true;
            dinoRunning = true;
            obstacles = [];
            nextObstacleDistance = 400;
            doubleObstacleChance = 0.3;
            
            document.getElementById('dino-score').textContent = dinoScore;
            document.getElementById('game-speed').textContent = Math.floor(gameSpeed / 5);
            
            // Iniciar animación de correr
            const dino = document.getElementById('dino');
            dino.classList.add('running');
            
            // Crear primer obstáculo
            crearObstaculo(800);
            
            // Game loop
            dinoGameInterval = setInterval(() => {
                if (!juegoActivo) return;
                
                // Mover obstáculos
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    obstacle.x -= gameSpeed;
                    obstacle.element.style.right = (800 - obstacle.x) + 'px';
                    
                    // Eliminar obstáculos fuera de pantalla
                    if (obstacle.x < -50) {
                        obstacle.element.remove();
                        obstacles.splice(i, 1);
                        dinoScore += 100;
                        document.getElementById('dino-score').textContent = dinoScore;
                        updateProgress(1, dinoScore / 50);
                        
                        // Aumentar velocidad gradualmente
                        if (dinoScore % 500 === 0 && gameSpeed < 12) {
                            gameSpeed += 0.2;
                            document.getElementById('game-speed').textContent = Math.floor(gameSpeed / 5);
                        }
                        
                        // Aumentar dificultad gradualmente
                        if (dinoScore % 1000 === 0) {
                            doubleObstacleChance = Math.min(doubleObstacleChance + 0.05, 0.6);
                        }
                        
                        if (dinoScore >= 5000) {
                            completarReto1();
                        }
                    }
                    
                    // Verificar colisión
                    checkCollision(obstacle);
                }
                
                // Crear nuevos obstáculos
                nextObstacleDistance -= gameSpeed;
                if (nextObstacleDistance <= 0) {
                    const lastObstacle = obstacles[obstacles.length - 1];
                    const newX = lastObstacle ? lastObstacle.x + 300 : 800;
                    
                    crearObstaculo(newX);
                    
                    // Posibilidad de doble obstáculo
                    if (Math.random() < doubleObstacleChance) {
                        setTimeout(() => {
                            crearObstaculo(newX + 150);
                        }, 100);
                    }
                    
                    nextObstacleDistance = 300 + Math.random() * 200;
                }
            }, 30);
        }
        
        function crearObstaculo(x) {
            const obstacle = document.createElement('div');
            obstacle.className = 'obstacle';
            obstacle.textContent = '🌳';
            obstacle.style.right = (800 - x) + 'px';
            document.getElementById('dino-game').appendChild(obstacle);
            
            obstacles.push({
                element: obstacle,
                x: x
            });
        }
        
        function checkCollision(obstacle) {
            const dino = document.getElementById('dino');
            const dinoRect = dino.getBoundingClientRect();
            const obstacleRect = obstacle.element.getBoundingClientRect();
            
            // Ajustar la caja de colisión del dinosaurio según su estado
            let dinoTop = dinoRect.top;
            let dinoBottom = dinoRect.bottom;
            let dinoLeft = dinoRect.left;
            let dinoRight = dinoRect.right;
            
            // Si está saltando, ajustar la caja de colisión
            if (dinoJumping) {
                dinoTop += 10;
                dinoBottom -= 10;
            }
            
            // Verificar colisión con mayor precisión
            if (
                dinoRight > obstacleRect.left + 8 &&
                dinoLeft < obstacleRect.right - 8 &&
                dinoBottom > obstacleRect.top + 8 &&
                dinoTop < obstacleRect.bottom - 8
            ) {
                // Colisión
                vidas--;
                actualizarVidas();
                addLog(`Colisión detectada. Vidas restantes: ${vidas}`);
                
                // Efecto visual de colisión
                obstacle.element.style.filter = 'brightness(2)';
                setTimeout(() => {
                    obstacle.element.style.filter = '';
                }, 300);
                
                if (vidas <= 0) {
                    finDelJuego();
                } else {
                    // Eliminar el obstáculo con el que colisionó
                    obstacle.element.remove();
                    const index = obstacles.indexOf(obstacle);
                    if (index > -1) {
                        obstacles.splice(index, 1);
                    }
                }
            }
        }
        
        function saltarDino() {
            if (dinoJumping) return;
            
            dinoJumping = true;
            dinoRunning = false;
            const dino = document.getElementById('dino');
            dino.classList.remove('running');
            dino.classList.add('jumping');
            
            setTimeout(() => {
                dino.classList.remove('jumping');
                dinoJumping = false;
                if (juegoActivo) {
                    dinoRunning = true;
                    dino.classList.add('running');
                }
            }, 800);
        }
        
        function completarReto1() {
            juegoActivo = false;
            clearInterval(dinoGameInterval);
            document.removeEventListener('keydown', handleKeyDown);
            
            // Limpiar obstáculos
            obstacles.forEach(obstacle => {
                obstacle.element.remove();
            });
            obstacles = [];
            
            const dino = document.getElementById('dino');
            dino.classList.remove('running');
            
            addLog("Reto 1 completado. Puntuación alcanzada: 5000");
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 2000);
        }
        
        function mostrarReto2() {
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">RETO 2: Memoria Secuencial</div>
                    <div class="reto-description">
                        <p>Observa la secuencia de números y luego pulsalos en orden ascendente.</p>
                        <p>Cada ronda añade un número más. Debes completar 15 rondas.</p>
                    </div>
                    <div class="game-area">
                        <div class="round-info">Ronda: <span id="memory-round">1</span> / 15</div>
                        <div class="sequence-display" id="sequence-display">Preparando secuencia...</div>
                        <div class="memory-grid" id="memory-grid">
                            <!-- Las celdas se generarán aquí -->
                        </div>
                        <div class="progress-bar">
                            <div class="progress" id="progress2"></div>
                        </div>
                    </div>
                </div>
            `;
            
            iniciarJuegoMemoria();
            addLog("Iniciando Reto 2: Memoria Secuencial");
        }
        
        function iniciarJuegoMemoria() {
            memoryRound = 1;
            memorySequence = [];
            memoryPlayerSequence = [];
            memoryShowing = false;
            
            crearGridMemoria();
            siguienteRondaMemoria();
        }
        
        function crearGridMemoria() {
            const grid = document.getElementById('memory-grid');
            grid.innerHTML = '';
            memoryGrid = [];
            
            // Crear 25 celdas (5x5)
            for (let i = 0; i < 25; i++) {
                const cell = document.createElement('div');
                cell.className = 'memory-cell';
                cell.dataset.index = i;
                
                // Crear frente y dorso de la carta
                const front = document.createElement('div');
                front.className = 'memory-cell-front';
                front.textContent = '?';
                
                const back = document.createElement('div');
                back.className = 'memory-cell-back';
                back.textContent = 'X'; // Por defecto, todas las celdas tienen X
                
                cell.appendChild(front);
                cell.appendChild(back);
                cell.addEventListener('click', () => pulsarCeldaMemoria(i));
                grid.appendChild(cell);
                memoryGrid.push(cell);
            }
        }
        
        function siguienteRondaMemoria() {
            document.getElementById('memory-round').textContent = memoryRound;
            updateProgress(2, (memoryRound - 1) / 15);
            
            // Añadir nuevo número a la secuencia
            const nuevoNumero = memoryRound;
            memorySequence.push(nuevoNumero);
            
            // Mostrar secuencia
            mostrarSecuenciaMemoria();
        }
        
        function mostrarSecuenciaMemoria() {
            memoryShowing = true;
            memoryPlayerSequence = [];
            
            const display = document.getElementById('sequence-display');
            display.textContent = 'Observa la secuencia...';
            
            // Limpiar celdas (voltear todas)
            memoryGrid.forEach(cell => {
                cell.classList.remove('flipped');
            });
            
            // Mostrar números uno por uno
            let delay = 0;
            const positions = [];
            
            // Generar posiciones aleatorias para cada número
            for (let i = 0; i < memorySequence.length; i++) {
                let pos;
                do {
                    pos = Math.floor(Math.random() * 25);
                } while (positions.includes(pos));
                positions.push(pos);
            }
            
            // Establecer los números en las celdas correspondientes
            memorySequence.forEach((num, index) => {
                const cell = memoryGrid[positions[index]];
                const back = cell.querySelector('.memory-cell-back');
                back.textContent = num;
            });
            
            // Mostrar cada número
            memorySequence.forEach((num, index) => {
                memoryTimeout = setTimeout(() => {
                    const cell = memoryGrid[positions[index]];
                    cell.classList.add('flipped');
                    
                    // Ocultar después de un tiempo
                    setTimeout(() => {
                        cell.classList.remove('flipped');
                        if (index === memorySequence.length - 1) {
                            // Último número, permitir al jugador
                            setTimeout(() => {
                                display.textContent = '¡Ahora pulsa los números en orden!';
                                memoryShowing = false;
                            }, 500);
                        }
                    }, 1000);
                }, delay);
                
                delay += 1500; // 1.5 segundos entre números
            });
        }
        
        function pulsarCeldaMemoria(index) {
            if (memoryShowing) return;
            
            const cell = memoryGrid[index];
            const back = cell.querySelector('.memory-cell-back');
            const expectedNum = memoryPlayerSequence.length + 1;
            
            // Voltear la celda
            cell.classList.add('flipped');
            
            // Verificar si es correcto
            if (back.textContent === expectedNum.toString()) {
                // Correcto
                cell.classList.add('correct');
                memoryPlayerSequence.push(expectedNum);
                
                setTimeout(() => {
                    cell.classList.remove('correct');
                    
                    // Verificar si completó la ronda
                    if (memoryPlayerSequence.length === memorySequence.length) {
                        // Ronda completada
                        if (memoryRound >= 15) {
                            completarReto2();
                        } else {
                            memoryRound++;
                            setTimeout(() => {
                                siguienteRondaMemoria();
                            }, 1000);
                        }
                    }
                }, 500);
            } else {
                // Incorrecto
                cell.classList.add('wrong');
                vidas--;
                actualizarVidas();
                addLog(`Secuencia incorrecta. Vidas restantes: ${vidas}`);
                
                setTimeout(() => {
                    cell.classList.remove('wrong');
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        // Reiniciar ronda
                        setTimeout(() => {
                            mostrarSecuenciaMemoria();
                        }, 1000);
                    }
                }, 500);
            }
        }
        
        function completarReto2() {
            clearTimeout(memoryTimeout);
            addLog("Reto 2 completado. Todas las rondas superadas.");
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 2000);
        }
        
        function mostrarReto3() {
            const p = preguntaFinal;
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">RETO 3: Pregunta Final</div>
                    <div class="question">
                        <p><strong>PREGUNTA FINAL:</strong> ${p.pregunta}</p>
                        <input type="text" id="respuesta-final" placeholder="Introduce tu respuesta">
                        <button onclick="verificarRespuestaFinal()">Verificar</button>
                        <button onclick="mostrarPistaFinal()">Usar pista (${3 - pistasUsadas} restantes)</button>
                    </div>
                </div>
            `;
            
            document.getElementById('respuesta-final').focus();
            addLog("Iniciando Reto 3: Pregunta Final");
        }
        
        function verificarRespuestaFinal() {
            const respuesta = document.getElementById('respuesta-final').value.toLowerCase().trim();
            const correcta = preguntaFinal.respuesta.toLowerCase();
            
            if (respuesta === correcta) {
                addLog("Respuesta correcta. Reto final completado.");
                retoActual++;
                setTimeout(() => {
                    mostrarRetoActual();
                }, 2000);
            } else {
                vidas--;
                actualizarVidas();
                addLog(`Respuesta incorrecta. Vidas restantes: ${vidas}`);
                
                if (vidas <= 0) {
                    finDelJuego();
                } else {
                    document.getElementById('respuesta-final').value = '';
                    document.getElementById('respuesta-final').focus();
                }
            }
        }
        
        function mostrarPistaFinal() {
            if (pistasUsadas < 3) {
                pistasUsadas++;
                const pista = document.getElementById('hint');
                pista.textContent = `PISTA: ${preguntaFinal.pista}`;
                pista.classList.add('show');
                addLog(`Pista solicitada: ${preguntaFinal.pista.substring(0, 20)}...`);
                
                setTimeout(() => {
                    pista.classList.remove('show');
                }, 10000);
            }
        }
        
        function mostrarReto4() {
            binaryLevel = 1;
            binaryAttempts = 0;
            stegoRevealed = false;
            
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">RETO 4: Lógica Binaria</div>
                    <div class="reto-description">
                        <p>Resuelve las operaciones lógicas binarias para superar este reto.</p>
                        <p>Debes completar 5 niveles de dificultad creciente.</p>
                    </div>
                    <div class="game-area">
                        <div class="binary-container">
                            <div class="binary-level">Nivel: <span id="binary-level">1</span> / 5</div>
                            <div class="binary-attempts">Intentos: <span id="binary-attempts">0</span> / 3</div>
                            <div class="binary-operation" id="binary-operation">Cargando operación...</div>
                            <div class="binary-hint" id="binary-hint"></div>
                            <input type="text" id="binary-answer" class="binary-input" placeholder="Respuesta binaria">
                            <button onclick="verificarRespuestaBinaria()">Verificar</button>
                            <div class="progress-bar">
                                <div class="progress" id="progress4"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            generarOperacionBinaria();
            addLog("Iniciando Reto 4: Lógica Binaria");
        }
        
        function generarOperacionBinaria() {
            document.getElementById('binary-level').textContent = binaryLevel;
            document.getElementById('binary-attempts').textContent = binaryAttempts;
            
            let operacion, respuesta, pista;
            
            // Generar operación según el nivel
            switch(binaryLevel) {
                case 1:
                    // Operación simple: AND/OR/XOR entre dos números
                    const num1 = Math.floor(Math.random() * 8) + 1;
                    const num2 = Math.floor(Math.random() * 8) + 1;
                    const ops = ['AND', 'OR', 'XOR'];
                    const op = ops[Math.floor(Math.random() * ops.length)];
                    
                    operacion = `${num1.toString(2).padStart(3, '0')} ${op} ${num2.toString(2).padStart(3, '0')}`;
                    
                    if (op === 'AND') {
                        respuesta = (num1 & num2).toString(2).padStart(3, '0');
                    } else if (op === 'OR') {
                        respuesta = (num1 | num2).toString(2).padStart(3, '0');
                    } else {
                        respuesta = (num1 ^ num2).toString(2).padStart(3, '0');
                    }
                    
                    pista = "Recuerda: AND=1 solo si ambos bits son 1, OR=1 si al menos un bit es 1, XOR=1 si los bits son diferentes.";
                    break;
                    
                case 2:
                    // Operación con NOT
                    const num3 = Math.floor(Math.random() * 16) + 1;
                    operacion = `NOT(${num3.toString(2).padStart(4, '0')})`;
                    respuesta = (~num3 & 0xF).toString(2).padStart(4, '0');
                    pista = "NOT invierte todos los bits: 0→1 y 1→0.";
                    break;
                    
                case 3:
                    // Operación combinada
                    const num4 = Math.floor(Math.random() * 8) + 1;
                    const num5 = Math.floor(Math.random() * 8) + 1;
                    const num6 = Math.floor(Math.random() * 8) + 1;
                    operacion = `(${num4.toString(2).padStart(3, '0')} AND ${num5.toString(2).padStart(3, '0')}) OR ${num6.toString(2).padStart(3, '0')}`;
                    respuesta = ((num4 & num5) | num6).toString(2).padStart(3, '0');
                    pista = "Resuelve primero la operación entre paréntesis.";
                    break;
                    
                case 4:
                    // Operación con desplazamiento
                    const num7 = Math.floor(Math.random() * 32) + 1;
                    const shift = Math.floor(Math.random() * 3) + 1;
                    const direction = Math.random() < 0.5 ? '<<' : '>>';
                    
                    operacion = `${num7.toString(2).padStart(5, '0')} ${direction} ${shift}`;
                    
                    if (direction === '<<') {
                        respuesta = ((num7 << shift) & 0x1F).toString(2).padStart(5, '0');
                    } else {
                        respuesta = (num7 >> shift).toString(2).padStart(5, '0');
                    }
                    
                    pista = "<< desplaza bits a la izquierda, >> desplaza bits a la derecha.";
                    break;
                    
                case 5:
                    // Operación compleja
                    const num8 = Math.floor(Math.random() * 16) + 1;
                    const num9 = Math.floor(Math.random() * 16) + 1;
                    const num10 = Math.floor(Math.random() * 16) + 1;
                    operacion = `NOT(${num8.toString(2).padStart(4, '0')} AND ${num9.toString(2).padStart(4, '0')}) XOR ${num10.toString(2).padStart(4, '0')}`;
                    respuesta = ((~(num8 & num9) & 0xF) ^ num10).toString(2).padStart(4, '0');
                    pista = "Resuelve paso a paso: primero el AND, luego el NOT, finalmente el XOR.";
                    break;
            }
            
            currentBinaryOperation = operacion;
            binaryAnswer = respuesta;
            
            document.getElementById('binary-operation').textContent = operacion + " = ?";
            document.getElementById('binary-hint').textContent = pista;
            document.getElementById('binary-answer').value = '';
            document.getElementById('binary-answer').focus();
            
            updateProgress(4, (binaryLevel - 1) / 5);
        }
        
        function verificarRespuestaBinaria() {
            const respuesta = document.getElementById('binary-answer').value.trim();
            
            if (respuesta === binaryAnswer) {
                addLog(`Respuesta binaria correcta: ${binaryAnswer}`);
                
                if (binaryLevel >= 5) {
                    completarReto4();
                } else {
                    binaryLevel++;
                    binaryAttempts = 0;
                    setTimeout(() => {
                        generarOperacionBinaria();
                    }, 1500);
                }
            } else {
                binaryAttempts++;
                document.getElementById('binary-attempts').textContent = binaryAttempts;
                
                if (binaryAttempts >= maxBinaryAttempts) {
                    vidas--;
                    actualizarVidas();
                    addLog(`Máximo de intentos alcanzado. Vidas restantes: ${vidas}`);
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        binaryAttempts = 0;
                        setTimeout(() => {
                            generarOperacionBinaria();
                        }, 1000);
                    }
                } else {
                    addLog(`Respuesta incorrecta. Intentos restantes: ${maxBinaryAttempts - binaryAttempts}`);
                    document.getElementById('binary-answer').value = '';
                    document.getElementById('binary-answer').focus();
                }
            }
        }
        
        function completarReto4() {
            addLog("Reto 4 completado. Todos los niveles de lógica binaria superados.");
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 2000);
        }
        
        function mostrarReto5() {
            stegoAttempts = 0;
            stegoRevealed = false;
            
            // Generar texto con mensaje oculto
            generarTextoEsteganografia();
            
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">RETO 5: Esteganografía Avanzada</div>
                    <div class="reto-description">
                        <p>Encuentra el mensaje oculto en el siguiente texto usando técnicas de esteganografía.</p>
                        <p>El mensaje está codificado usando múltiples capas de ocultación.</p>
                    </div>
                    <div class="game-area">
                        <div class="stego-container">
                            <div class="stego-attempts">Intentos: <span id="stego-attempts">0</span> / 3</div>
                            <div class="stego-text" id="stego-text">${stegoText}</div>
                            <div class="stego-hint" id="stego-hint">
                                El mensaje está oculto usando técnicas avanzadas de esteganografía.
                                Debes encontrar el patrón binario oculto, convertirlo a colores y reconocer la bandera.
                            </div>
                            <div class="stego-tools">
                                <div class="stego-tool" onclick="revelarPista1()">Pista 1: Binario</div>
                                <div class="stego-tool" onclick="revelarPista2()">Pista 2: Colores</div>
                                <div class="stego-tool" onclick="revelarPista3()">Pista 3: Bandera</div>
                            </div>
                            <div class="stego-colors" id="stego-colors"></div>
                            <input type="text" id="stego-answer" class="stego-input" placeholder="Mensaje oculto">
                            <button onclick="verificarRespuestaEsteganografia()">Verificar</button>
                            <div class="progress-bar">
                                <div class="progress" id="progress5"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('stego-attempts').textContent = stegoAttempts;
            updateProgress(5, 0);
            addLog("Iniciando Reto 5: Esteganografía Avanzada");
        }
        
        function generarTextoEsteganografia() {
            // Mensaje a ocultar: "España"
            stegoMessage = "España";
            
            // Convertir el mensaje a binario (cada carácter a 8 bits)
            stegoBinary = "";
            for (let i = 0; i < stegoMessage.length; i++) {
                const charCode = stegoMessage.charCodeAt(i);
                stegoBinary += charCode.toString(2).padStart(8, '0');
            }
            
            // Convertir binario a colores (cada 8 bits = 1 byte = 1 color RGB)
            stegoColors = [];
            for (let i = 0; i < stegoBinary.length; i += 8) {
                const byte = stegoBinary.substr(i, 8);
                const decimal = parseInt(byte, 2);
                
                // Mapear el valor decimal a colores de la bandera de España
                // Rojo: valores bajos (0-85), Amarillo: valores medios (86-170), Rojo: valores altos (171-255)
                let color;
                if (decimal <= 85) {
                    // Rojo español
                    color = `rgb(${170 + Math.floor(decimal / 85 * 85)}, 0, 0)`;
                } else if (decimal <= 170) {
                    // Amarillo español
                    const yellowValue = Math.floor((decimal - 86) / 84 * 255);
                    color = `rgb(${yellowValue}, ${yellowValue}, 0)`;
                } else {
                    // Rojo español
                    color = `rgb(${170 + Math.floor((decimal - 171) / 84 * 85)}, 0, 0)`;
                }
                
                stegoColors.push(color);
            }
            
            // Texto base con esteganografía
            const textoBase = `El sistema operativo es la base fundamental de cualquier computadora moderna. 
            Los algoritmos de encriptación garantizan la seguridad de los datos transmitidos. 
            La arquitectura de red determina cómo se conectan los dispositivos entre sí. 
            Los protocolos de comunicación establecen las reglas para el intercambio de información. 
            La inteligencia artificial está transformando numerosas industrias. 
            El análisis de datos permite descubrir patrones ocultos en grandes volúmenes de información. 
            La realidad virtual crea experiencias inmersivas para los usuarios. 
            La computación cuántica promete revolucionar el procesamiento de información.`;
            
            // Ocultar el binario en el texto usando espacios y caracteres invisibles
            let textoConBinario = "";
            let binIndex = 0;
            
            for (let i = 0; i < textoBase.length; i++) {
                const char = textoBase[i];
                textoConBinario += char;
                
                // Insertar bits usando espacios y caracteres invisibles
                if (char === ' ' && binIndex < stegoBinary.length) {
                    if (stegoBinary[binIndex] === '1') {
                        textoConBinario += '  '; // Espacio doble para bit 1
                    } else {
                        textoConBinario += ' '; // Espacio simple para bit 0
                    }
                    binIndex++;
                }
            }
            
            stegoText = textoConBinario;
        }
        
        function revelarPista1() {
            if (!stegoRevealed) {
                document.getElementById('stego-hint').innerHTML = `
                    <strong>Pista 1:</strong> Los espacios dobles representan bits '1' y los espacios simples representan bits '0'.
                    <br><strong>Secuencia binaria:</strong> ${stegoBinary}
                `;
                stegoRevealed = true;
            }
        }
        
        function revelarPista2() {
            if (!stegoRevealed) {
                document.getElementById('stego-hint').innerHTML = `
                    <strong>Pista 2:</strong> Cada grupo de 8 bits forma un byte que representa un color RGB.
                    <br><strong>Valores decimales:</strong> ${stegoBinary.match(/.{1,8}/g).map(byte => parseInt(byte, 2)).join(', ')}
                `;
                stegoRevealed = true;
            }
        }
        
        function revelarPista3() {
            if (!stegoRevealed) {
                // Mostrar los colores
                const colorsContainer = document.getElementById('stego-colors');
                colorsContainer.innerHTML = '';
                
                stegoColors.forEach(color => {
                    const colorBox = document.createElement('div');
                    colorBox.className = 'color-box';
                    colorBox.style.backgroundColor = color;
                    colorsContainer.appendChild(colorBox);
                });
                
                document.getElementById('stego-hint').innerHTML = `
                    <strong>Pista 3:</strong> Los colores forman la bandera de España (rojo-amarillo-rojo).
                    <br><strong>Colores RGB:</strong> ${stegoColors.join(', ')}
                `;
                stegoRevealed = true;
            }
        }
        
        function verificarRespuestaEsteganografia() {
            const respuesta = document.getElementById('stego-answer').value.trim();
            
            if (respuesta.toLowerCase() === "españa") {
                addLog("✅ Mensaje esteganográfico correcto");
                completarReto5();
            } else {
                stegoAttempts++;
                document.getElementById('stego-attempts').textContent = stegoAttempts;
                
                if (stegoAttempts >= maxStegoAttempts) {
                    vidas--;
                    actualizarVidas();
                    addLog(`Máximo de intentos alcanzado. Vidas restantes: ${vidas}`);
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        stegoAttempts = 0;
                        setTimeout(() => {
                            mostrarReto5();
                        }, 1000);
                    }
                } else {
                    addLog(`Mensaje incorrecto. Intentos restantes: ${maxStegoAttempts - stegoAttempts}`);
                    document.getElementById('stego-answer').value = '';
                    document.getElementById('stego-answer').focus();
                }
            }
        }
        
        function completarReto5() {
            addLog("🎉 Reto 5 completado");
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 2000);
        }
        
        // ============================================
        // RETO 6: LSB Canvas Interactivo
        // ============================================
        
        function mostrarReto6() {
            lsbAttempts = 0;
            lsbExtractedBits = [];
            lsbCurrentPixel = {x: 0, y: 0};
            
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">🔬 RETO 6: Análisis LSB de Imagen</div>
                    <div class="reto-description">
                        <p>Una imagen contiene un mensaje oculto usando esteganografía LSB (Least Significant Bit).</p>
                        <p>Debes analizar los bits menos significativos de los píxeles para extraer el mensaje secreto.</p>
                        <p style="color: #ff0;">⚠️ Este reto requiere análisis profundo y uso de herramientas avanzadas.</p>
                    </div>
                    
                    <div class="game-area">
                        <div class="lsb-container">
                            <!-- Información de intentos -->
                            <div style="text-align: center; margin-bottom: 20px;">
                                <span style="color: #ff0; font-size: 1.1em;">Intentos: <span id="lsb-attempts">0</span> / 3</span>
                            </div>
                            
                            <!-- Canvas con la imagen -->
                            <div class="lsb-canvas-wrapper">
                                <canvas id="lsb-canvas" width="400" height="100"></canvas>
                            </div>
                            
                            <!-- Información del píxel bajo el cursor -->
                            <div class="pixel-info" id="pixel-info">
                                <div style="text-align: center; color: #ff0; margin-bottom: 10px;">
                                    <strong>📍 Información del Píxel</strong>
                                </div>
                                <div class="pixel-info-row">
                                    <span>Posición:</span>
                                    <span id="pixel-pos">Mueve el cursor sobre la imagen</span>
                                </div>
                                <div class="pixel-info-row">
                                    <span>RGB:</span>
                                    <span id="pixel-rgb">-</span>
                                </div>
                                <div class="pixel-info-row">
                                    <span>Binario R:</span>
                                    <span id="pixel-bin-r" style="font-family: 'Courier New';">-</span>
                                </div>
                                <div class="pixel-info-row">
                                    <span>Binario G:</span>
                                    <span id="pixel-bin-g" style="font-family: 'Courier New';">-</span>
                                </div>
                                <div class="pixel-info-row">
                                    <span>Binario B:</span>
                                    <span id="pixel-bin-b" style="font-family: 'Courier New';">-</span>
                                </div>
                                <div class="pixel-info-row" style="border-top: 2px solid #0f0; margin-top: 5px; padding-top: 5px;">
                                    <span>LSB:</span>
                                    <span id="pixel-lsb" style="color: #ff0; font-weight: bold;">-</span>
                                </div>
                            </div>
                            
                            <!-- Controles de análisis -->
                            <div class="lsb-controls">
                                <div class="lsb-control-panel">
                                    <h3>🔧 Herramientas de Extracción</h3>
                                    <button class="lsb-button" onclick="extraerLSBManual()">
                                        🔍 Extraer LSB Manual
                                    </button>
                                    <button class="lsb-button" onclick="extraerLSBAuto()">
                                        ⚡ Extracción Automática
                                    </button>
                                    <button class="lsb-button" onclick="mostrarBinarioCompleto()">
                                        📊 Ver Secuencia Binaria
                                    </button>
                                    <button class="lsb-button" onclick="decodificarASCII()">
                                        📝 Decodificar a ASCII
                                    </button>
                                </div>
                                
                                <div class="lsb-control-panel">
                                    <h3>🎨 Análisis de Canales</h3>
                                    <button class="lsb-button" onclick="analizarCanal('red')">
                                        🔴 Canal Rojo
                                    </button>
                                    <button class="lsb-button" onclick="analizarCanal('green')">
                                        🟢 Canal Verde
                                    </button>
                                    <button class="lsb-button" onclick="analizarCanal('blue')">
                                        🔵 Canal Azul
                                    </button>
                                    <button class="lsb-button" onclick="analizarCanal('all')">
                                        ⚪ Todos los Canales
                                    </button>
                                </div>
                                
                                <div class="lsb-control-panel">
                                    <h3>💡 Pistas</h3>
                                    <button class="lsb-button" onclick="mostrarPistaLSB(1)">
                                        💭 Pista 1: ¿Qué es LSB?
                                    </button>
                                    <button class="lsb-button" onclick="mostrarPistaLSB(2)">
                                        💭 Pista 2: Canal correcto
                                    </button>
                                    <button class="lsb-button" onclick="mostrarPistaLSB(3)">
                                        💭 Pista 3: Decodificación
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Análisis de espectro -->
                            <div class="spectrum-analyzer" id="spectrum-analyzer" style="display: none;">
                                <h3 style="color: #ff0; text-align: center; margin-bottom: 15px;">📊 Análisis de Canales RGB</h3>
                                <div class="color-channel">
                                    <div>🔴 Canal Rojo - LSB: <span id="red-lsb-count">0</span> bits extraídos</div>
                                    <div class="channel-bar">
                                        <div class="channel-fill red" id="red-fill" style="width: 0%;"></div>
                                    </div>
                                </div>
                                <div class="color-channel">
                                    <div>🟢 Canal Verde - LSB: <span id="green-lsb-count">0</span> bits extraídos</div>
                                    <div class="channel-bar">
                                        <div class="channel-fill green" id="green-fill" style="width: 0%;"></div>
                                    </div>
                                </div>
                                <div class="color-channel">
                                    <div>🔵 Canal Azul - LSB: <span id="blue-lsb-count">0</span> bits extraídos</div>
                                    <div class="channel-bar">
                                        <div class="channel-fill blue" id="blue-fill" style="width: 0%;"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Display de binario -->
                            <div class="binary-display" id="binary-display" style="display: none;">
                                <h3 style="color: #ff0; text-align: center; margin-bottom: 10px;">🔢 Secuencia Binaria Extraída</h3>
                                <div id="binary-content"></div>
                            </div>
                            
                            <!-- Mensaje extraído -->
                            <div id="extracted-message-container"></div>
                            
                            <!-- Crypto hint -->
                            <div class="crypto-hint" id="lsb-hint">
                                <strong>💡 Información:</strong> El mensaje está oculto en los bits menos significativos (LSB) de los píxeles.
                                Cada píxel RGB tiene 3 bytes, y cada byte tiene 8 bits. El LSB es el bit en la posición 0 (el último).
                            </div>
                            
                            <!-- Input de respuesta -->
                            <div style="text-align: center; margin-top: 20px;">
                                <input type="text" id="lsb-answer" placeholder="Introduce el mensaje oculto" 
                                       style="width: 300px; text-align: center; font-size: 1.1em; padding: 10px;">
                                <br>
                                <button onclick="verificarRespuestaLSB()" style="margin-top: 10px; padding: 10px 30px; font-size: 1.1em;">
                                    ✅ Verificar Respuesta
                                </button>
                            </div>
                            
                            <!-- Barra de progreso -->
                            <div class="progress-bar">
                                <div class="progress" id="progress6"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar canvas
            setTimeout(() => {
                inicializarCanvasLSB();
            }, 100);
            
            updateProgress(6, 0);
            addLog("Iniciando Reto 6: Análisis LSB de Imagen");
        }
        
        function inicializarCanvasLSB() {
            lsbCanvas = document.getElementById('lsb-canvas');
            lsbCtx = lsbCanvas.getContext('2d');
            
            // Generar imagen con mensaje oculto en LSB
            generarImagenConLSB();
            
            // Event listeners para el canvas
            lsbCanvas.addEventListener('mousemove', actualizarInfoPixel);
            lsbCanvas.addEventListener('click', marcarPixel);
        }
        
        function generarImagenConLSB() {
            const width = lsbCanvas.width;
            const height = lsbCanvas.height;
            
            // Crear ImageData
            lsbImageData = lsbCtx.createImageData(width, height);
            const data = lsbImageData.data;
            
            // Mensaje a ocultar: "SIMULACION"
            lsbMessage = "SIMULACION";
            
            // Convertir mensaje a binario
            let binaryMessage = "";
            for (let i = 0; i < lsbMessage.length; i++) {
                const charCode = lsbMessage.charCodeAt(i);
                binaryMessage += charCode.toString(2).padStart(8, '0');
            }
            
            // Añadir marcador de fin
            binaryMessage += "00000000";
            
            let bitIndex = 0;
            
            // Llenar píxeles con colores aleatorios y ocultar mensaje en LSB del canal verde
            for (let i = 0; i < data.length; i += 4) {
                // Generar colores aleatorios
                const r = Math.floor(Math.random() * 256);
                const g = Math.floor(Math.random() * 256);
                const b = Math.floor(Math.random() * 256);
                
                // Asignar colores
                data[i] = r;         // R
                data[i + 2] = b;     // B
                data[i + 3] = 255;   // A (alpha)
                
                // Ocultar bit en el canal verde (LSB)
                if (bitIndex < binaryMessage.length) {
                    const bit = parseInt(binaryMessage[bitIndex]);
                    // Modificar el LSB del canal verde
                    data[i + 1] = (g & 0xFE) | bit; // Limpiar LSB y poner el bit del mensaje
                    bitIndex++;
                } else {
                    data[i + 1] = g;
                }
            }
            
            // Dibujar imagen en canvas
            lsbCtx.putImageData(lsbImageData, 0, 0);
            
            addLog("Imagen generada para análisis LSB");
        }
        
        function actualizarInfoPixel(e) {
            const rect = lsbCanvas.getBoundingClientRect();
            const x = Math.floor(e.clientX - rect.left);
            const y = Math.floor(e.clientY - rect.top);
            
            if (x >= 0 && x < lsbCanvas.width && y >= 0 && y < lsbCanvas.height) {
                const pixelData = lsbCtx.getImageData(x, y, 1, 1).data;
                const r = pixelData[0];
                const g = pixelData[1];
                const b = pixelData[2];
                
                // Actualizar información
                document.getElementById('pixel-pos').textContent = `(${x}, ${y})`;
                document.getElementById('pixel-rgb').textContent = `R:${r} G:${g} B:${b}`;
                document.getElementById('pixel-bin-r').textContent = r.toString(2).padStart(8, '0');
                document.getElementById('pixel-bin-g').textContent = g.toString(2).padStart(8, '0');
                document.getElementById('pixel-bin-b').textContent = b.toString(2).padStart(8, '0');
                
                // Mostrar LSB de cada canal
                const lsbR = r & 1;
                const lsbG = g & 1;
                const lsbB = b & 1;
                document.getElementById('pixel-lsb').textContent = `R:${lsbR} G:${lsbG} B:${lsbB}`;
                
                lsbCurrentPixel = {x, y};
            }
        }
        
        function marcarPixel(e) {
            const rect = lsbCanvas.getBoundingClientRect();
            const x = Math.floor(e.clientX - rect.left);
            const y = Math.floor(e.clientY - rect.top);
            
            // Dibujar un pequeño círculo en el píxel seleccionado
            lsbCtx.strokeStyle = '#ff0';
            lsbCtx.lineWidth = 2;
            lsbCtx.strokeRect(x - 2, y - 2, 4, 4);
            
            addLog(`Píxel marcado en (${x}, ${y})`);
        }
        
        function extraerLSBManual() {
            addLog("Extracción manual LSB iniciada...");
            
            const data = lsbImageData.data;
            let extractedBits = "";
            
            // Extraer LSB del canal verde de los primeros 100 píxeles
            for (let i = 0; i < Math.min(400, data.length / 4); i++) {
                const pixelIndex = i * 4;
                const g = data[pixelIndex + 1];
                const lsb = g & 1;
                extractedBits += lsb;
            }
            
            lsbExtractedBits = extractedBits;
            
            // Mostrar primeros bits
            document.getElementById('lsb-hint').innerHTML = `
                <strong>📊 Extracción Manual:</strong><br>
                Primeros 80 bits del canal verde: <span style="font-family: 'Courier New'; color: #ff0;">${extractedBits.substring(0, 80)}</span>
                <br><br>
                <strong>💡 Nota:</strong> Agrupa los bits en grupos de 8 para formar bytes, luego convierte a ASCII.
            `;
            
            updateProgress(6, 0.25);
            addLog(`Extraídos ${extractedBits.length} bits del canal verde`);
        }
        
        function extraerLSBAuto() {
            addLog("Extracción automática LSB iniciada...");
            
            const data = lsbImageData.data;
            let extractedBits = "";
            
            // Extraer LSB del canal verde de todos los píxeles
            for (let i = 1; i < data.length; i += 4) {
                const lsb = data[i] & 1;
                extractedBits += lsb;
            }
            
            lsbExtractedBits = extractedBits;
            
            // Mostrar análisis de canales
            document.getElementById('spectrum-analyzer').style.display = 'block';
            document.getElementById('green-lsb-count').textContent = extractedBits.length;
            document.getElementById('green-fill').style.width = '100%';
            
            updateProgress(6, 0.5);
            addLog(`Extracción automática completada: ${extractedBits.length} bits`);
        }
        
        function mostrarBinarioCompleto() {
            if (lsbExtractedBits.length === 0) {
                addLog("⚠️ Primero debes extraer los bits LSB");
                return;
            }
            
            const binaryDisplay = document.getElementById('binary-display');
            const binaryContent = document.getElementById('binary-content');
            
            binaryDisplay.style.display = 'block';
            binaryContent.innerHTML = '';
            
            // Mostrar bits en grupos de 8
            for (let i = 0; i < Math.min(160, lsbExtractedBits.length); i += 8) {
                const byte = lsbExtractedBits.substring(i, i + 8).padEnd(8, '0');
                const decimal = parseInt(byte, 2);
                const char = decimal > 0 ? String.fromCharCode(decimal) : '?';
                
                const row = document.createElement('div');
                row.className = 'binary-row';
                row.innerHTML = `
                    <span style="color: #0f0;">Byte ${i/8}:</span>
                    ${byte.split('').map((bit, idx) => 
                        `<span class="binary-bit ${bit === '1' ? 'one' : ''}">${bit}</span>`
                    ).join('')}
                    <span style="color: #ff0; margin-left: 10px;">= ${decimal} (${char})</span>
                `;
                binaryContent.appendChild(row);
            }
            
            updateProgress(6, 0.75);
            addLog("Secuencia binaria visualizada");
        }
        
        function decodificarASCII() {
            if (lsbExtractedBits.length === 0) {
                addLog("⚠️ Primero debes extraer los bits LSB");
                return;
            }
            
            let mensaje = "";
            
            // Convertir bits a caracteres
            for (let i = 0; i < lsbExtractedBits.length; i += 8) {
                const byte = lsbExtractedBits.substring(i, i + 8);
                if (byte.length === 8) {
                    const decimal = parseInt(byte, 2);
                    if (decimal === 0) break; // Fin del mensaje
                    if (decimal >= 32 && decimal <= 126) {
                        mensaje += String.fromCharCode(decimal);
                    }
                }
            }
            
            // Mostrar mensaje
            const container = document.getElementById('extracted-message-container');
            container.innerHTML = `
                <div class="lsb-extracted-message">
                    <div style="font-size: 1.5em; color: #ff0; margin-bottom: 10px;">🎉 MENSAJE EXTRAÍDO</div>
                    <div style="font-size: 2em; color: #0f0; font-weight: bold; letter-spacing: 3px;">
                        ${mensaje}
                    </div>
                    <div style="margin-top: 10px; font-size: 0.9em; color: #aaa;">
                        Introduce este mensaje en el campo de respuesta
                    </div>
                </div>
            `;
            
            updateProgress(6, 0.9);
            addLog("Mensaje ASCII decodificado exitosamente");
        }
        
        function analizarCanal(canal) {
            const data = lsbImageData.data;
            let channelBits = "";
            let channelIndex;
            
            switch(canal) {
                case 'red':
                    channelIndex = 0;
                    addLog("Analizando canal ROJO...");
                    break;
                case 'green':
                    channelIndex = 1;
                    addLog("Analizando canal VERDE...");
                    break;
                case 'blue':
                    channelIndex = 2;
                    addLog("Analizando canal AZUL...");
                    break;
                case 'all':
                    addLog("Analizando TODOS los canales...");
                    break;
            }
            
            if (canal !== 'all') {
                for (let i = channelIndex; i < data.length; i += 4) {
                    channelBits += (data[i] & 1);
                }
                
                const mensaje = extraerMensajeDebits(channelBits);
                addLog(`Canal ${canal}: ${channelBits.length} bits extraídos`);
            } else {
                // Analizar todos
                const rBits = extraerCanalBits(data, 0);
                const gBits = extraerCanalBits(data, 1);
                const bBits = extraerCanalBits(data, 2);
                
                addLog(`Análisis completo de canales RGB realizado`);
            }
            
            document.getElementById('spectrum-analyzer').style.display = 'block';
        }
        
        function extraerCanalBits(data, channelIndex) {
            let bits = "";
            for (let i = channelIndex; i < data.length; i += 4) {
                bits += (data[i] & 1);
            }
            return bits;
        }
        
        function extraerMensajeDebits(bits) {
            let mensaje = "";
            for (let i = 0; i < bits.length && i < 800; i += 8) {
                const byte = bits.substring(i, i + 8);
                if (byte.length === 8) {
                    const decimal = parseInt(byte, 2);
                    if (decimal === 0) break;
                    if (decimal >= 32 && decimal <= 126) {
                        mensaje += String.fromCharCode(decimal);
                    }
                }
            }
            return mensaje;
        }
        
        function mostrarPistaLSB(numero) {
            const hints = {
                1: `<strong>💡 Pista 1 - ¿Qué es LSB?</strong><br>
                    LSB (Least Significant Bit) es el bit menos significativo de un byte. En un byte de 8 bits,
                    es el bit en la posición 0 (el último). Por ejemplo, en el número binario 10110101, el LSB es 1.<br>
                    <strong>En esteganografía:</strong> Se modifican los LSBs de los píxeles para ocultar información sin
                    cambiar visiblemente la imagen.`,
                
                2: `<strong>💡 Pista 2 - Canal Correcto</strong><br>
                    El mensaje está oculto en el <span style="color: #0f0; font-weight: bold;">canal VERDE</span> de la imagen.<br>
                    Cada píxel tiene 3 valores (R, G, B). Debes extraer el LSB del valor G de cada píxel.<br>
                    <strong>Consejo:</strong> Usa la herramienta "Extraer LSB Manual" o "Extracción Automática".`,
                
                3: `<strong>💡 Pista 3 - Decodificación</strong><br>
                    Una vez extraídos los bits, agrúpalos de 8 en 8 para formar bytes.<br>
                    Cada byte representa un código ASCII de un carácter.<br>
                    El mensaje termina cuando encuentres un byte con valor 0 (00000000).<br>
                    <strong>Respuesta:</strong> La palabra que debes introducir tiene 10 letras y comienza con "S".`
            };
            
            document.getElementById('lsb-hint').innerHTML = hints[numero];
            addLog(`Pista ${numero} revelada`);
        }
        
        function verificarRespuestaLSB() {
            const respuesta = document.getElementById('lsb-answer').value.trim().toUpperCase();
            
            if (respuesta === lsbMessage.toUpperCase()) {
                addLog("✅ Respuesta correcta");
                completarReto6();
            } else {
                lsbAttempts++;
                document.getElementById('lsb-attempts').textContent = lsbAttempts;
                
                if (lsbAttempts >= maxLsbAttempts) {
                    vidas--;
                    actualizarVidas();
                    addLog(`❌ Máximo de intentos alcanzado. Vidas restantes: ${vidas}`);
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        lsbAttempts = 0;
                        setTimeout(() => {
                            mostrarReto6();
                        }, 1000);
                    }
                } else {
                    addLog(`❌ Respuesta incorrecta. Intentos restantes: ${maxLsbAttempts - lsbAttempts}`);
                    document.getElementById('lsb-answer').value = '';
                    document.getElementById('lsb-answer').focus();
                }
            }
        }
        
        function completarReto6() {
            updateProgress(6, 1);
            addLog("🎉 Reto 6 completado exitosamente");
            
            document.getElementById('question-container').innerHTML += `
                <div style="text-align: center; margin-top: 30px; padding: 20px; background: rgba(0, 100, 0, 0.3); border: 2px solid #0f0; border-radius: 10px;">
                    <h2 style="color: #0f0;">✅ RETO 6 COMPLETADO</h2>
                    <p style="font-size: 1.2em;">Has dominado el análisis LSB de imágenes.</p>
                    <p>Preparando siguiente reto...</p>
                </div>
            `;
            
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 3000);
        }
        
        // ============================================
        // RETO 7: Criptograma Multi-Capa
        // ============================================
        
        function mostrarReto7() {
            cryptoAttempts = 0;
            currentCryptoLayer = 0;
            cryptoCompletedLayers = [];
            
            // Definir las capas de cifrado
            cryptoLayers = [
                {
                    nombre: "Capa 1: Cifrado César",
                    tipo: "caesar",
                    shift: 13,
                    textoOriginal: "RAPERPR QRCVRAR GR FREHER QRY ZRAGHER",
                    respuesta: "ENEMIGO DELANTE TE SEGUEN DEL MENSAJE",
                    descripcion: "Un cifrado César con desplazamiento ROT13",
                    pista: "El desplazamiento es 13. También conocido como ROT13."
                },
                {
                    nombre: "Capa 2: Cifrado Vigenère",
                    tipo: "vigenere",
                    clave: "CLAVE",
                    textoOriginal: "XSMEC LSXIV KW GMHIE MW ZEQSIRW",
                    respuesta: "VALOR ENTRE EL CAUCE DE PALABRAS",
                    descripcion: "Cifrado Vigenère con clave secreta",
                    pista: "La clave es: CLAVE (literalmente)"
                },
                {
                    nombre: "Capa 3: Sustitución + Base64",
                    tipo: "mixed",
                    textoOriginal: "VkZSSFRrZEpUVU5GVTBGTlFVeEpWRUU=",
                    respuesta: "TREDINCINCESAMALITA",
                    descripcion: "Primero decodifica Base64, luego descifra la sustitución",
                    pista: "Primero Base64, luego busca patrones de frecuencia"
                },
                {
                    nombre: "Capa Final: Criptograma Complejo",
                    tipo: "complex",
                    textoOriginal: "Uji gmnhjbmso mbmpo pm yji omhbuj pm nubxjmo, pm vuwojmo, pm vuwqbmojmo",
                    respuesta: "EJE SEMANTICO CLAVE DE JUE SENTIE DE NUSUJIE DE SUSSABIE DE SUESUABIE",
                    descripcion: "Múltiples técnicas combinadas",
                    pista: "Analiza la frecuencia de letras. La 'J' aparece mucho..."
                }
            ];
            
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">🔐 RETO 7: Criptograma Multi-Capa</div>
                    <div class="reto-description">
                        <p>Debes descifrar 4 capas de cifrado de complejidad creciente.</p>
                        <p>Cada capa desbloqueada te dará una pista para la siguiente.</p>
                        <p style="color: #ff0;">⚠️ Usa análisis de frecuencias, tablas de sustitución y herramientas de descifrado.</p>
                    </div>
                    
                    <div class="game-area">
                        <div class="crypto-container">
                            <!-- Información de intentos -->
                            <div style="text-align: center; margin-bottom: 20px;">
                                <span style="color: #ff0; font-size: 1.1em;">
                                    Capa actual: <span id="crypto-current-layer">1</span> / 4 | 
                                    Intentos: <span id="crypto-attempts">0</span> / 3
                                </span>
                            </div>
                            
                            <!-- Capas de cifrado -->
                            <div class="crypto-layers" id="crypto-layers-container">
                                <!-- Las capas se generarán dinámicamente -->
                            </div>
                            
                            <!-- Herramientas globales -->
                            <div class="crypto-tools">
                                <div class="crypto-tool">
                                    <h4>🔧 Decodificador Base64</h4>
                                    <textarea id="base64-input" rows="3" style="width: 100%; background: #000; color: #0f0; border: 1px solid #0f0; padding: 5px; margin: 5px 0;"></textarea>
                                    <button class="lsb-button" onclick="decodificarBase64Tool()">Decodificar</button>
                                    <div id="base64-output" style="margin-top: 10px; padding: 10px; background: rgba(0,20,0,0.5); border: 1px solid #0f0; min-height: 30px;"></div>
                                </div>
                                
                                <div class="crypto-tool">
                                    <h4>🔄 Cifrado César</h4>
                                    <div class="tool-input-group">
                                        <label>Texto:</label>
                                        <input type="text" id="caesar-input" style="flex: 1;">
                                    </div>
                                    <div class="tool-input-group">
                                        <label>Desplazamiento:</label>
                                        <input type="number" id="caesar-shift" value="13" min="1" max="25" style="width: 60px;">
                                        <button class="lsb-button" onclick="descifrarCesarTool()">Descifrar</button>
                                    </div>
                                    <div id="caesar-output" style="margin-top: 10px; padding: 10px; background: rgba(0,20,0,0.5); border: 1px solid #0f0; min-height: 30px;"></div>
                                </div>
                                
                                <div class="crypto-tool">
                                    <h4>🔑 Cifrado Vigenère</h4>
                                    <div class="tool-input-group">
                                        <label>Texto:</label>
                                        <input type="text" id="vigenere-input" style="flex: 1;">
                                    </div>
                                    <div class="tool-input-group">
                                        <label>Clave:</label>
                                        <input type="text" id="vigenere-key" placeholder="CLAVE" style="flex: 1;">
                                        <button class="lsb-button" onclick="descifrarVigenereTool()">Descifrar</button>
                                    </div>
                                    <div id="vigenere-output" style="margin-top: 10px; padding: 10px; background: rgba(0,20,0,0.5); border: 1px solid #0f0; min-height: 30px;"></div>
                                </div>
                            </div>
                            
                            <!-- Análisis de frecuencias -->
                            <div class="frequency-analysis" id="frequency-analysis">
                                <h3 style="color: #ff0; text-align: center; margin-bottom: 15px;">📊 Análisis de Frecuencias</h3>
                                <div style="text-align: center; margin-bottom: 15px;">
                                    <input type="text" id="freq-text-input" placeholder="Pega el texto a analizar" style="width: 80%; padding: 8px;">
                                    <button class="lsb-button" onclick="analizarFrecuencias()" style="width: auto; display: inline-block;">Analizar</button>
                                </div>
                                <div class="freq-chart" id="freq-chart">
                                    <!-- Las barras se generarán dinámicamente -->
                                </div>
                                <div style="font-size: 0.85em; color: #aaa; text-align: center;">
                                    En español, las letras más frecuentes son: E, A, O, S, R, N, I, D, L, C
                                </div>
                            </div>
                            
                            <!-- Barra de progreso -->
                            <div class="progress-bar">
                                <div class="progress" id="progress7"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Generar las capas
            setTimeout(() => {
                generarCapasCripto();
            }, 100);
            
            updateProgress(7, 0);
            addLog("Iniciando Reto 7: Criptograma Multi-Capa");
        }
        
        function generarCapasCripto() {
            const container = document.getElementById('crypto-layers-container');
            container.innerHTML = '';
            
            cryptoLayers.forEach((capa, index) => {
                const isLocked = index > currentCryptoLayer;
                const isCompleted = cryptoCompletedLayers.includes(index);
                const isActive = index === currentCryptoLayer;
                
                let statusClass = 'locked';
                let statusText = '🔒 BLOQUEADA';
                
                if (isCompleted) {
                    statusClass = 'completed';
                    statusText = '✅ COMPLETADA';
                } else if (isActive) {
                    statusClass = 'unlocked';
                    statusText = '🔓 ACTIVA';
                }
                
                const capaDiv = document.createElement('div');
                capaDiv.className = `crypto-layer ${isLocked ? 'locked' : ''} ${isCompleted ? 'completed' : ''}`;
                capaDiv.innerHTML = `
                    <div class="layer-header">
                        <div class="layer-title">${capa.nombre}</div>
                        <div class="layer-status ${statusClass}">${statusText}</div>
                    </div>
                    
                    ${!isLocked ? `
                        <div class="encrypted-text">${capa.textoOriginal}</div>
                        
                        <div style="margin: 15px 0;">
                            <strong>📝 Descripción:</strong> ${capa.descripcion}
                        </div>
                        
                        ${isActive && !isCompleted ? `
                            <div style="margin: 15px 0;">
                                <button class="lsb-button" onclick="mostrarPistaCripto(${index})">💡 Mostrar Pista</button>
                            </div>
                            
                            <div class="crypto-hint" id="crypto-hint-${index}" style="display: none;">
                                ${capa.pista}
                            </div>
                            
                            <div style="text-align: center; margin-top: 15px;">
                                <input type="text" id="crypto-answer-${index}" placeholder="Texto descifrado" 
                                       style="width: 70%; padding: 10px; text-align: center;">
                                <br>
                                <button onclick="verificarCapaCripto(${index})" 
                                        style="margin-top: 10px; padding: 10px 30px;">
                                    ✅ Verificar Capa ${index + 1}
                                </button>
                            </div>
                        ` : ''}
                        
                        ${isCompleted ? `
                            <div style="text-align: center; padding: 15px; background: rgba(50,50,0,0.3); border: 1px solid #ff0; border-radius: 5px;">
                                <strong style="color: #ff0;">✅ RESPUESTA CORRECTA:</strong> 
                                <span style="color: #0f0; font-size: 1.1em;">${capa.respuesta}</span>
                            </div>
                        ` : ''}
                    ` : `
                        <div style="text-align: center; padding: 30px; color: #666;">
                            🔒 Completa la capa anterior para desbloquear
                        </div>
                    `}
                `;
                
                container.appendChild(capaDiv);
                
                // Añadir conector visual entre capas
                if (index < cryptoLayers.length - 1) {
                    const connector = document.createElement('div');
                    connector.className = 'layer-connections';
                    connector.innerHTML = isCompleted ? '✅ ⬇️' : '🔒 ⬇️';
                    container.appendChild(connector);
                }
            });
            
            document.getElementById('crypto-current-layer').textContent = currentCryptoLayer + 1;
        }
        
        function mostrarPistaCripto(index) {
            const hintElement = document.getElementById(`crypto-hint-${index}`);
            if (hintElement) {
                hintElement.style.display = 'block';
                addLog(`Pista revelada para Capa ${index + 1}`);
            }
        }
        
        function verificarCapaCripto(index) {
            const inputElement = document.getElementById(`crypto-answer-${index}`);
            if (!inputElement) return;
            
            const respuesta = inputElement.value.trim().toUpperCase().replace(/\s+/g, ' ');
            const respuestaCorrecta = cryptoLayers[index].respuesta.toUpperCase().replace(/\s+/g, ' ');
            
            // Permitir cierta flexibilidad en la respuesta
            const similitud = calcularSimilitud(respuesta, respuestaCorrecta);
            
            if (similitud > 0.8 || respuesta === respuestaCorrecta) {
                addLog(`✅ Capa ${index + 1} descifrada correctamente`);
                cryptoCompletedLayers.push(index);
                currentCryptoLayer++;
                
                const progreso = (currentCryptoLayer / cryptoLayers.length);
                updateProgress(7, progreso);
                
                // Verificar si es la última capa
                if (currentCryptoLayer >= cryptoLayers.length) {
                    completarReto7();
                } else {
                    // Regenerar capas para mostrar la siguiente
                    generarCapasCripto();
                    addLog(`🔓 Capa ${currentCryptoLayer + 1} desbloqueada`);
                }
            } else {
                cryptoAttempts++;
                document.getElementById('crypto-attempts').textContent = cryptoAttempts;
                
                if (cryptoAttempts >= maxCryptoAttempts) {
                    vidas--;
                    actualizarVidas();
                    addLog(`❌ Máximo de intentos alcanzado. Vidas restantes: ${vidas}`);
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        cryptoAttempts = 0;
                        setTimeout(() => {
                            mostrarReto7();
                        }, 1000);
                    }
                } else {
                    addLog(`❌ Respuesta incorrecta para Capa ${index + 1}. Intentos: ${cryptoAttempts}/${maxCryptoAttempts}`);
                    if (similitud > 0.5) {
                        addLog(`💡 Estás cerca... Revisa la ortografía y espacios`);
                    }
                    inputElement.value = '';
                    inputElement.focus();
                }
            }
        }
        
        function calcularSimilitud(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const editDistance = calcularDistanciaEdicion(longer, shorter);
            return (longer.length - editDistance) / longer.length;
        }
        
        function calcularDistanciaEdicion(str1, str2) {
            const costs = [];
            for (let i = 0; i <= str1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= str2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else if (j > 0) {
                        let newValue = costs[j - 1];
                        if (str1.charAt(i - 1) !== str2.charAt(j - 1)) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
                if (i > 0) costs[str2.length] = lastValue;
            }
            return costs[str2.length];
        }
        
        // Herramientas de descifrado
        function decodificarBase64Tool() {
            const input = document.getElementById('base64-input').value.trim();
            try {
                const decoded = atob(input);
                document.getElementById('base64-output').textContent = decoded;
                addLog(`Base64 decodificado: ${decoded.substring(0, 50)}...`);
            } catch (e) {
                document.getElementById('base64-output').textContent = '❌ Error: No es Base64 válido';
                addLog('Error al decodificar Base64');
            }
        }
        
        function descifrarCesarTool() {
            const input = document.getElementById('caesar-input').value.toUpperCase();
            const shift = parseInt(document.getElementById('caesar-shift').value) || 13;
            
            let resultado = '';
            for (let i = 0; i < input.length; i++) {
                const char = input[i];
                if (char >= 'A' && char <= 'Z') {
                    const code = ((char.charCodeAt(0) - 65 - shift + 26) % 26) + 65;
                    resultado += String.fromCharCode(code);
                } else {
                    resultado += char;
                }
            }
            
            document.getElementById('caesar-output').textContent = resultado;
            addLog(`César descifrado (shift ${shift})`);
        }
        
        function descifrarVigenereTool() {
            const input = document.getElementById('vigenere-input').value.toUpperCase().replace(/[^A-Z]/g, '');
            const key = document.getElementById('vigenere-key').value.toUpperCase().replace(/[^A-Z]/g, '');
            
            if (!key) {
                document.getElementById('vigenere-output').textContent = '❌ Introduce una clave';
                return;
            }
            
            let resultado = '';
            for (let i = 0, j = 0; i < input.length; i++) {
                const charCode = input.charCodeAt(i);
                if (charCode >= 65 && charCode <= 90) {
                    const keyChar = key.charCodeAt(j % key.length) - 65;
                    const decrypted = ((charCode - 65 - keyChar + 26) % 26) + 65;
                    resultado += String.fromCharCode(decrypted);
                    j++;
                } else {
                    resultado += input[i];
                }
            }
            
            document.getElementById('vigenere-output').textContent = resultado;
            addLog("Vigenère descifrado exitosamente");
        }
        
        function analizarFrecuencias() {
            const text = document.getElementById('freq-text-input').value.toUpperCase().replace(/[^A-Z]/g, '');
            
            if (!text) {
                addLog('⚠️ Introduce un texto para analizar');
                return;
            }
            
            // Contar frecuencias
            const freq = {};
            for (let char of text) {
                freq[char] = (freq[char] || 0) + 1;
            }
            
            // Convertir a array y ordenar
            const sortedFreq = Object.entries(freq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15); // Top 15
            
            // Calcular máximo para normalizar
            const maxFreq = sortedFreq[0][1];
            
            // Generar gráfico
            const chart = document.getElementById('freq-chart');
            chart.innerHTML = '';
            
            sortedFreq.forEach(([char, count]) => {
                const height = (count / maxFreq) * 100;
                const percentage = ((count / text.length) * 100).toFixed(1);
                
                const bar = document.createElement('div');
                bar.className = 'freq-bar';
                bar.style.height = `${height}%`;
                bar.innerHTML = `
                    <div class="freq-label">${char}</div>
                    <div class="freq-value">${count} (${percentage}%)</div>
                `;
                chart.appendChild(bar);
            });
            
            addLog(`Análisis de frecuencias completado: ${text.length} caracteres analizados`);
        }
        
        function completarReto7() {
            updateProgress(7, 1);
            addLog("🎉 Reto 7 completado. Todas las capas descifradas.");
            
            document.getElementById('crypto-layers-container').innerHTML += `
                <div style="text-align: center; margin-top: 30px; padding: 30px; background: rgba(0, 100, 0, 0.3); border: 2px solid #0f0; border-radius: 10px;">
                    <h2 style="color: #0f0; font-size: 2em;">🏆 RETO 7 COMPLETADO</h2>
                    <p style="font-size: 1.3em; margin: 20px 0;">Has dominado el arte de la criptografía clásica.</p>
                    <p style="color: #ff0;">Todas las capas han sido descifradas con éxito.</p>
                    <p style="margin-top: 20px;">Preparando capa final de seguridad...</p>
                </div>
            `;
            
            retoActual++;
            setTimeout(() => {
                mostrarRetoActual();
            }, 4000);
        }
        
        function mostrarCapaFinal() {
            securityStep = 1;
            securityAttempts = 0;
            
            // Mensaje cifrado final
            securityMessage = "535441524c4947485420435245505455444f";
            
            document.getElementById('question-container').innerHTML = `
                <div class="reto-container">
                    <div class="reto-title">CAPA FINAL DE SEGURIDAD</div>
                    <div class="reto-description">
                        <p>Has superado todos los retos, pero aún debes descifrar el mensaje final.</p>
                        <p>Este es el último obstáculo antes de obtener el acceso completo.</p>
                    </div>
                    <div class="game-area">
                        <div class="final-security">
                            <div class="security-step">Paso: <span id="security-step">1</span> / 4</div>
                            <div class="security-attempts">Intentos: <span id="security-attempts">0</span> / 3</div>
                            
                            <div class="security-text" id="security-text">
                                ${securityMessage}
                            </div>
                            
                            <div class="security-hint" id="security-hint">
                                <strong>Pista inicial:</strong> El mensaje está codificado en hexadecimal. 
                                Conviértelo a texto para continuar.
                            </div>
                            
                            <div class="security-tools">
                                <div class="tool-row">
                                    <label>Resultado:</label>
                                    <input type="text" id="security-result" placeholder="Introduce el resultado">
                                </div>
                            </div>
                            
                            <button onclick="verificarPasoSeguridad()">Verificar</button>
                            
                            <div class="book-excerpt" id="book-excerpt" style="display: none;">
                                <!-- El extracto del libro se mostrará aquí -->
                            </div>
                            
                            <div class="progress-bar">
                                <div class="progress" id="progress6"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('security-attempts').textContent = securityAttempts;
            updateProgress(6, 0);
            addLog("Iniciando Capa Final de Seguridad");
        }
        
        function verificarPasoSeguridad() {
            const resultado = document.getElementById('security-result').value.trim();
            let correcto = false;
            
            switch(securityStep) {
                case 1:
                    // Paso 1: Hexadecimal a texto
                    if (resultado === "STARLIGHT CREPTUDO") {
                        correcto = true;
                        securityStep++;
                        securityMessage = "U1RBUkxJR0hUIENSRVBUVURPIFRFWFRPIEZJTkFMCg==";
                        
                        document.getElementById('security-step').textContent = securityStep;
                        document.getElementById('security-text').textContent = securityMessage;
                        document.getElementById('security-hint').innerHTML = `
                            <strong>Paso 2:</strong> El nuevo mensaje está en Base64. 
                            Conviértelo a texto para continuar.
                        `;
                        document.getElementById('security-result').value = '';
                        updateProgress(6, 0.25);
                        
                        addLog("Paso 1 completado: Hexadecimal a texto");
                    }
                    break;
                    
                case 2:
                    // Paso 2: Base64 a texto
                    if (resultado === "STARLIGHT CREPTUDO TEXT OF FINAL") {
                        correcto = true;
                        securityStep++;
                        securityMessage = "V1hWVUdZVUJUWVJXVlVHWVVCVFZSV1ZVRllVQlRWUlc=";
                        
                        document.getElementById('security-step').textContent = securityStep;
                        document.getElementById('security-text').textContent = securityMessage;
                        document.getElementById('security-hint').innerHTML = `
                            <strong>Paso 3:</strong> Este mensaje también está en Base64, pero necesitas una clave.
                            <br>La clave está en el libro "Simulacros y Simulación", página 42, línea 3, palabra 5.
                        `;
                        document.getElementById('security-result').value = '';
                        
                        // Mostrar extracto del libro
                        const bookExcerpt = `Página 42:
                        Línea 1: La simulación no es una copia de lo real, sino que reemplaza a lo real.
                        Línea 2: En la era de la simulación, los signos ya no remiten a nada real.
                        Línea 3: El mapa precede al territorio y genera el territorio. La simulación es la realidad.
                        Línea 4: Hiperrealidad es el resultado de la simulación total.
                        Línea 5: Los modelos generan lo real sin necesidad de referentes externos.`;
                        
                        document.getElementById('book-excerpt').textContent = bookExcerpt;
                        document.getElementById('book-excerpt').style.display = 'block';
                        
                        updateProgress(6, 0.5);
                        
                        addLog("Paso 2 completado: Base64 a texto");
                    }
                    break;
                    
                case 3:
                    // Paso 3: Base64 con clave
                    if (resultado.toLowerCase() === "simulacion") {
                        correcto = true;
                        securityStep++;
                        securityMessage = "V1hWVUdZVUJUWVJXVlVHWVVCVFZSV1ZVRllVQlRWUlc=";
                        
                        document.getElementById('security-step').textContent = securityStep;
                        document.getElementById('security-text').textContent = securityMessage;
                        document.getElementById('security-hint').innerHTML = `
                            <strong>Paso 4:</strong> Usa la clave encontrada para descifrar el mensaje Base64.
                            <br>El resultado final es la contraseña del sistema.
                        `;
                        document.getElementById('security-result').value = '';
                        updateProgress(6, 0.75);
                        
                        addLog("Paso 3 completado: Clave encontrada");
                    }
                    break;
                    
                case 4:
                    // Paso 4: Descifrar con clave
                    if (resultado.toLowerCase() === "reconquista") {
                        correcto = true;
                        updateProgress(6, 1);
                        
                        addLog("✅ Capa final completada");
                        setTimeout(() => {
                            mostrarCompletado();
                        }, 2000);
                    }
                    break;
            }
            
            if (!correcto) {
                securityAttempts++;
                document.getElementById('security-attempts').textContent = securityAttempts;
                
                if (securityAttempts >= maxSecurityAttempts) {
                    vidas--;
                    actualizarVidas();
                    addLog(`Máximo de intentos alcanzado. Vidas restantes: ${vidas}`);
                    
                    if (vidas <= 0) {
                        finDelJuego();
                    } else {
                        securityAttempts = 0;
                        setTimeout(() => {
                            mostrarCapaFinal();
                        }, 1000);
                    }
                } else {
                    addLog(`Respuesta incorrecta. Intentos restantes: ${maxSecurityAttempts - securityAttempts}`);
                    document.getElementById('security-result').value = '';
                    document.getElementById('security-result').focus();
                }
            }
        }
        
        function updateProgress(reto, porcentaje) {
            const progress = document.getElementById(`progress${reto}`);
            if (progress) {
                progress.style.width = `${porcentaje * 100}%`;
            }
        }
        
        function mostrarCompletado() {
            document.getElementById('question-container').innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <h2 style="color: #0f0; font-size: 2.5em; margin-bottom: 20px;">✅ ACCESO CONCEDIDO</h2>
                    <p style="font-size: 1.3em; margin: 20px 0;">Has superado todas las capas de seguridad del sistema.</p>
                    <p style="color: #ff0; font-size: 1.2em; margin: 20px 0;">¡Felicidades por completar el desafío!</p>
                    <p style="margin-top: 30px; font-size: 1.1em;">Redirigiendo a tu recompensa en <span id="countdown">5</span> segundos...</p>
                    <button onclick="window.location.href='final.html'" style="margin-top: 20px; padding: 15px 40px; font-size: 1.2em; background: #0f0; color: #000; border: none; border-radius: 5px; cursor: pointer;">
                        🎁 IR AHORA A LA RECOMPENSA
                    </button>
                </div>
            `;
            addLog("✅ Verificación completada. Acceso concedido al sistema.");
            
            // Countdown y redirección automática
            let countdown = 5;
            const countdownInterval = setInterval(() => {
                countdown--;
                const countdownElement = document.getElementById('countdown');
                if (countdownElement) {
                    countdownElement.textContent = countdown;
                }
                
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    window.location.href = 'final.html';
                }
            }, 1000);
        }
        
        function finDelJuego() {
            juegoActivo = false;
            clearInterval(dinoGameInterval);
            clearTimeout(memoryTimeout);
            document.removeEventListener('keydown', handleKeyDown);
            
            document.getElementById('question-container').innerHTML = `
                <h2>ACCESO DENEGADO</h2>
                <p>Has bloqueado el sistema al acumular suficientes errores. Reiniciando....</p>
                <button onclick="location.reload()">Reiniciar sistema</button>
            `;
            addLog("Sistema bloqueado. Demasiados intentos fallidos.");
        }
        
        // Función para verificar el código de desarrollo
        function verificarDevCode() {
            const code = document.getElementById('dev-code').value;
            
            // Determinar qué password usar según la fase del juego
            let passwordValida = false;
            
            // Password 05973784V: válida hasta el reto 5 (esteganografía) inclusive
            // Password 05912037W: válida para retos 6 y 7
            if (code === '05973784V' && (preguntaActual < preguntas.length || retoActual <= 4)) {
                passwordValida = true;
                addLog("Código de desarrollo aceptado [05973784V]. Avanzando...");
            } else if (code === '05912037W' && retoActual >= 5) {
                passwordValida = true;
                addLog("Código de desarrollo aceptado [05912037W]. Avanzando...");
            } else if (code === '5659448') {
                // Código maestro (backdoor de desarrollo)
                passwordValida = true;
                addLog("Código maestro aceptado. Avanzando...");
            }
            
            if (passwordValida) {
                // Si estamos en las preguntas, avanzar a la siguiente pregunta
                if (preguntaActual < preguntas.length) {
                    preguntaActual++;
                    mostrarPregunta();
                } 
                // Si estamos en los retos, avanzar al siguiente reto
                else if (retoActual < 8) {
                    retoActual++;
                    mostrarRetoActual();
                }
                // Si ya completamos todo, mostrar completado
                else {
                    mostrarCompletado();
                }
                
                // Limpiar el campo de código
                document.getElementById('dev-code').value = '';
            } else {
                addLog("Código de desarrollo incorrecto");
            }
        }
        
        // Iniciar el juego cuando el DOM esté completamente cargado
        document.addEventListener('DOMContentLoaded', function() {
            mostrarPregunta();
            addLog("Sistema listo. Esperando entrada del usuario...");
        });
    </script>
</body>
</html>
